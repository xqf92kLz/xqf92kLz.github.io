模板：

```asm
.386
data segment use16
data ends
code segment use16
assume cs:code,ds:data
main:

   mov ah, 4Ch
   mov al, 0
   int 21h
code ends
end main
```

### 数据的表示与运算

- 数据的表示

    - 有符号数与无符号数

        - 有符号数：具有符号位，用于表示正数和负数。用补码存储。
        
        	表示范围：$[-2^{n-1},2^{n-1}-1]$，其中非负数范围为 $[0,2^{n-1}-1]$，负数范围为 $[-2^{n-1},-1]$。
			
			??? abstract "补码"
			
                - 补码定义：$x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
                
                    ??? info
                
                        - 原码：最高位为符号位，其余为数值位。
                
                        - 反码：正数反码 = 原码；负数反码 = 原码符号位不变、数值位取反。
                
                            $x_{反码}=\begin{cases}x&(x\geq 0)\\2^n-1-|x|&(x<0)\end{cases}$
                
                        - 补码：正数补码 = 原码；负数补码 = 反码 + 1。
                
                            $x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
                
                            性质：设 $a,b>0$，$a_{补码}+(-b)_{补码}=a+(2^n-b)\equiv a-b\pmod {2^n}$。
                
                            因此补码不仅统一了 $+0$ 与 $-0$，也实现了加法与减法的统一。
                
                - 由补码求真值：$x=\begin{cases}x_{补码}&(0\leq x_{补码}<2^{n-1})\\x_{补码}-2^n&(2^{n-1}\leq x_{补码}<2^n)\end{cases}$

        - 无符号数：无符号位，均为数值位。
        
        	表示范围：$[0,2^n-1]$。

    - 十六进制常数：后缀 `h` 或 `H`，且若十六进制常数恰好以字母开头，需要添加 `0` 前缀（如 `0FFFFh` 相当于 C 语言的 `0xFFFF`）。

        二进制常数：后缀 `B`。

- 运算

    - 算术运算：

        - `+`：`add ax,bx` 表示 `ax+=bx`

        - `-`：`sub ax,bx`

        - `*`：`imul`（有符号），`mul`（无符号）
        
			单操作数（`mul`，`imul`）：

              | 数据宽度            | 被乘数（隐含） | 乘数（显式操作）            | 结果                   |
              | ------------------- | -------------- | --------------------------- | ---------------------- |
              | 8 位乘法            | `AL`（8 位）   | 8 位   | `AX`（16 位，`AH:AL`） |
              | 16 位乘法           | `AX`（16 位）  | 16 位 | `DX:AX`（32 位）       |
              | 32 位乘法           | `EAX`（32 位） | 32 位 | `EDX:EAX`（64 位）     |
              | 64 位乘法（x86-64） | `RAX`（64 位） | 64 位 | `RDX:RAX`（128 位）    |

			双操作数（`imul`）：

			`imul ax,bx`

              | 数据宽度        | 被乘数      | 乘数                    | 结果                |
              | --------------- | ----------- | ----------------------- | ------------------- |
              | 16 位           | 16 位寄存器 | 16 位 | 目标寄存器（16 位） |
              | 32 位           | 32 位寄存器 | 32 位 | 目标寄存器（32 位） |
              | 64 位（x86-64） | 64 位寄存器 | 64 位 | 目标寄存器（64 位） |

        - `/`：`idiv`（有符号），`div`（无符号）




            | 数据宽度            | 被除数（隐含）      | 除数（显式操作）            | 商（结果）     | 余数（结果）   |
            | ------------------- | ------------------- | --------------------------- | -------------- | -------------- |
            | 8 位除法            | `AX`（16 位）       | 8 位   | `AL`（8 位）   | `AH`（8 位）   |
            | 16 位除法           | `DX:AX`（32 位）    | 16 位 | `AX`（16 位）  | `DX`（16 位）  |
            | 32 位除法           | `EDX:EAX`（64 位）  | 32 位 | `EAX`（32 位） | `EDX`（32 位） |
            | 64 位除法（x86-64） | `RDX:RAX`（128 位） | 64 位 | `RAX`（64 位） | `RDX`（64 位） |
    
            ??? abstract "示例"
    
                ```asm
                mov dx, -1; 相当于mov dx, 0FFFFh
                mov ax, -6; 相当于mov ax, 0FFFAh
                          ; dx与ax组合起来就是0FFFFFFFAh, 它就是32位的-6  
                mov bx, 2 ; 当除数为16位的寄存器或变量时，被除数一定是=dx（高 16 位）:ax（低 16 位）
                idiv bx   ; ax=商=-3=0FFFDh, dx=余数=0=0000h
                ```
    
    - 关系运算：
    
        - `==`：`je`
        - `!=`：`jne`
        - `>`：有符号数 `jg`，无符号数 `ja`
        - `<`：有符号数 `jl`，无符号数 `jb`
        - `>=`：有符号数 `jge`，无符号数 `jae`
        - `<=`：有符号数 `jle`，无符号数 `jbe`
    
    - 逻辑运算：
    
        - `&&`：用两个嵌套的 if 实现。
        - `||`：用两个并列的 if 实现。
        - `!`
    
    - 位运算：
    
        - `&`：`and al,bl`
        - `|`：`or al,bl`
        - `^`：`xor al,bl`
        - `~`：`not ax`
        - `<<`：`shl al,1`。最后一个被移动的位会被放到 CF 标志中。
        
        	（与 `jc` 配合：若 CF=1，`jc` 会跳转）
        	
        - `>>`：`shr al,1`（无符号），`sar al,1`（有符号）。最后一个被移动的位会被放到 CF 标志中。
        - 循环左移 `rol`，循环右移 `ror`。最后一个被移动的位会在被放到另一端的同时放到 CF 标志中。

### int21h 中断

[常见中断](https://blog.csdn.net/Zach_z/article/details/78576216) `int 21h`：（[中断大全](https://www.uwouni.com/rbrown.htm)）

| AH   | 功能           | 调用参数         | 返回参数    |
| ---- | -------------- | ---------------- | ----------- |
| 00   | 程序终止       | CS=程序段前缀    |             |
| 01   | 键盘输入并回显 |                  | AL=输入字符 |
| 02   | 显示输出       | DL=输出字符（\r → 0Dh，\n → 0Ah）      |             |
| 09   | 显示字符串     | DS:DX=字符串地址 |             |
| 4C   | 带返回码结束   | AL=返回码        |             |

### 分支与循环

用跳转实现。

??? note "do-while"
    ```asm
    code segment
    assume cs:code
    main:
    mov ax,[l1] 
    outer_loop:
        mov bx,[l2]
        middle_loop:
            mov cx,[l3]
            inner_loop:
                ; 循环体操作
                add cx,1
                cmp cx,[r3]
                jle inner_loop     
            add bx,1
            cmp bx,[r2]
            jle middle_loop 
        add ax,1
        cmp ax,[r1]
        jle outer_loop
    code ends
    end main
    ```

### 函数

写在 `main` 前面，用 `call` 调用，用 `ret` 返回

### CPU、内存和端口

- 逻辑地址（段地址 : 偏移地址）
    - 在 8086 中，可以采用逻辑地址间接访问物理地址。物理地址 = 段地址 × 16 + 偏移地址。其中，段地址存储在 16 位段寄存器（如 `cs`、`ds`）中，偏移地址为 16 位值。

    	一个段可以表示的内存为 64KB，且段首地址的物理地址的 16 进制表示的个位必然是 0（段首地址 = 段地址 × 16）。
    
    - 引用变量：段地址只能用段寄存器表示，不能用常数表示。偏移地址可以常数表示。
    
    	- 直接寻址：`段寄存器:[偏移地址（常数）]`
    	- 间接寻址：只有 `bx`、`bp`、`si`、`di` 才可以放在 `[]` 内表示变量的偏移地址。
    	
    		① `段寄存器:[寄存器]`
    		
    		② `段寄存器:[寄存器±常数]`
    		
    		③ `段寄存器:[寄存器+寄存器]`：只能用 `[bx+si],[bx+di],[bp+si],[bp+di]`，不能 `[bx+bp],[si+di]`
    		
    		④ `段寄存器:[寄存器+寄存器±常数]`：不能  `[bx+bp±常数],[si+di±常数]`
    	
    - `seg s` 获取变量 s 所在段的段地址，`offset s` 获取 s 在段内的偏移地址。

- 宽度修饰

    | 宽度修饰词 | 限定变量的宽度 |
    | :--------: | :------------: |
    |  `byte ptr`  |      8 位      |
    |  `word ptr`  |     16 位      |
    | `dword ptr`  |     32 位      |

- 端口

	端口是 CPU 与 I/O 设备（如 CMOS 芯片、键盘、显示器）通信的 “接口”。
	
	例如 CPU 要读取当前所按键盘的编码或者读取 CMOS 芯片中的时间信息，都要借助相关端口才能达到目的。
	
	端口地址独立于内存地址，没有段地址，仅有 16 位偏移地址，取值范围是 [0000h,0FFFFh]。
	
	CMOS 芯片：负责存储系统时间、硬件配置等信息，通过 70h（地址端口）和 71h（数据端口）与 CPU 通信。
	
	in（读端口）、out（写端口）：
	
	- `in al, 端口号`：从指定端口读取一个字节的信号并保存到 AL 中
	
	- `out 端口号, al`：将 AL 中的信号输出到指定端口
	
	??? note "readtime.asm"
		```asm
		;例子: readtime.asm
        .386
        data segment use16
        ;                0  3  6
        current_time db "00:00:00", 0Dh, 0Ah, '$'
        data ends
        code segment use16
        assume cs:code, ds:data
        main:
           mov ax, data
           mov ds, ax
           mov al, 4
           out 70h, al ; 向70h端口发送信号4表示接着要读或写CMOS的4号内存单元
           in al, 71h  ; 从71h端口读取CMOS的4号单元之值(BCD码格式的小时值)
                       ; e.g. AL=19h means 7 pm
           call convert; 调用函数convert把AL中的小时值如19h转化成AL='1', AH='9'
           mov word ptr current_time[0], ax
           mov al, 2
           out 70h, al ; 向70h端口发送信号2表示接着要读或写CMOS的2号内存单元
           in  al, 71h ; 从71h端口读取CMOS的2号单元之值(BCD码格式的分钟值)
                       ; e.g. AL=56h means 56 minutes
           call convert; 调用函数convert把AL中的分钟值如56h转化成AL='5', AH='6'
           mov word ptr current_time[3],ax;
           ;mov current_time[3], al
           ;mov current_time[4], ah
           mov al, 0
           out 70h, al ; 向70h端口发送信号0表示接着要读或写CMOS的0号内存单元
           in  al, 71h ; 从71h端口读取CMOS的0号单元之值(BCD码格式的秒钟值)
           call convert; 调用函数convert把AL中的秒钟值如07h转化成AL='0', AH='7'
           mov word ptr current_time[6],ax
           mov ah, 9   ; 9号功能会输出ds:dx指向的字符串
           mov dx, offset current_time
           int 21h     ; 调用int 21h函数集中的9号子功能输出ds:dx指向的字符串
           mov ah, 4Ch
           int 21h
        ;---------Convert----------------
        ;Input:AL=hour or minute or second
        ;      format:e.g. hour 19h means 7 pm.
        ;Output: (e.g. when AL=19h as input)
        ;     AL='1'
        ;     AH='9'
        convert:
            mov ah, al ; e.g. assume AL=19h
            and ah, 0Fh; AH=09h    
            shr al, 4  ; AL=01h
            add ah, '0'; AH='9'
            add al, '0'; AL='1'
            ret
        ;---------End of Convert---------
        code ends
        end main
        ```

- 寄存器

	ax，bx，cx，dx，si，di，sp，bp，cs，ds，es，ss，ip，fl
	
	- 标志寄存器 FL
	
		FL 是一个 16 位寄存器，该寄存器整体的值无意义，它的意义在于它的各个位。其中 6 个位是状态标志 CF、ZF、SF、OF、PF、AF，3 个位是控制标志 DF、IF、TF，还有 7 个是保留位。
		
		| 位编号 | 简称 | 名称         | 核心功能                       |
		| ------ | ---- | ------------ | ------------------------------ |
		| 0      | CF   | 进位标志（Carry Flag）     | 无符号数运算的进位 / 借位      |
		| 2      | PF   | 奇偶标志（Parity Flag）     | 运算结果低 8 位 1 的个数奇偶性 |
		| 4      | AF   | 辅助进位标志（Auxiliary Flag） | BCD 码运算的低 4 位进位 / 借位 |
		| 6      | ZF   | 零标志（Zero Flag）       | 运算结果是否为 0               |
		| 7      | SF   | 符号标志（Sign Flag）     | 运算结果最高位（正负）         |
		| 8      | TF   | 陷阱标志（Trap Flag）     | 调试单步执行 |
		| 9      | IF   | 中断标志（Interrupt Flag）     | 允许 / 禁止硬件中断            |
		| A     | DF   | 方向标志（Direction Flag）     | 字符串操作的方向（正 / 反）    |
		| B     | OF   | 溢出标志（Overflow Flag）     | 有符号数运算是否溢出   |
		
		- TF：TF 用于让 CPU 进入单步模式。当 TF=1 时，每执行一条指令后，CPU 会自动插入一条 `int 01h` 中断。
		- CF：CF 会被 `add`、`sub`、`mul`、`imul` 及移位指令影响。当两数相加产生进位、两束相减产生借位、两数相乘的乘积宽度超过被乘数宽度、移位指令最后移出的那一位是 1 时，CF 置为 1，否则 CF 置为 0。
		
			相关指令：`jc`（CF=1 时跳转）、`jnc`（CF=0 时跳转）、`adc`（带进位加法）、`clc`（令 CF=0）、`stc`（令 CF=1）
		
		- ZF：ZF 会被算术运算、逻辑运算、移位运算影响，运算结果等于 0 时 ZF 置 1，否则 ZF 置 0。
		
			注意 `mov` 指令不影响任何标志位，ZF 保留上一条指令的状态
			
			相关指令：`jz`/`je`（ZF=1 跳转）、`jnz`/`jne`（ZF=0 跳转）
		
		- SF：SF 会被算术运算、逻辑运算、移位运算影响，SF 将被置为运算结果的最高位。运算结果最高位为 1（负数）时 SF=1，否则（正数）SF=0。
			
			相关指令：`js`（SF=1 跳转）、`jns`（SF=0 跳转）

		- OF：OF 会被 `add`、`sub`、`mul`、`imul`、移位指令影响。当两个正数相加变成负数、两个负数相加变成正数、两数相乘的乘积宽度超过被乘数宽度、移位前后最高位发生改变时，OF 置为 1，否则 OF 置为 0。
		
			相关指令：`jo`（OF=1 跳转）、`jno`（OF=0 跳转）
		
		- DF：用于控制字符串操作指令的寻址方向。当 DF=0 时，字符串操作按正方向（低地址到高地址）执行；当 DF=1 时，字符串操作按反方向（高地址到低地址）执行。
		
			相关指令：`cld`（令 DF=0）、`std`（令 DF=1）
			
			??? info "rep movsb"
				假定要把地址 1000h:0 处长度为 100h 的字节复制到目标地址 2000h:0
				
				```asm
				mov ax, 1000h
				mov ds, ax
				mov ax, 2000h
				mov es, ax
				mov si, 0
				mov di, 0
				mov cx, 100h
				cld ; DF=0 正方向
				rep movsb
				; 上面这条指令的执行过程如下:
				again:
				mov al, ds:[si]
				mov es:[di], al
				inc si ; SI++
				inc di ; DI++
				dec cx ; CX--
				jnz again
				```
				
				```asm
				mov ax, 1000h
				mov ds, ax
				mov ax, 2000h
				mov es, ax
				mov si, 100h-1
				mov di, 100h-1
				mov cx, 100h
				std ; DF=1 反方向
				rep movsb; 
				; 上面这条指令的执行过程如下:
				again:
				mov al, ds:[si]
				mov es:[di], al
				dec si ; SI--
				dec di ; DI--
				dec cx ; CX--
				jnz again
				```
      	      
				源 / 目标地址重叠时，需要注意复制的方向，避免数据覆盖

		- IF：IF 用于禁止或允许硬件中断。当 IF=0 时禁止硬件中断；当 IF=1 时允许硬件中断。

			相关指令：`cli`（令 IF=0）、`sti`（令 IF=1）

### 数组

- 数组的定义

    - 字节（byte）类型：db（8 位）

        `char a[100] = {'\0'};` → `a db 100 dup(0)`（dup：duplicate 重复。dup 可嵌套使用）

        `char a[3] = {1, 2, 3};` → `a db 1, 2, 3`
        
        `char a[100];` → `a db 100 dup(?)`（编译时默认 0）
        
        `char a[] = "Hello";` → `a db "Hello", 0`（需手动补 '\0'）
        
        `char a[] = "Hello\0World";` → `a db "Hello", 0, "World", 0`
        
        `char a[] = "Hello\n";` → `a db "Hello", 0Dh, 0Ah, 0` 或 `a db "Hello", 13, 10, 0` 或 `a db "Hello", 15Q, 12Q, 0`（Q 表示八进制数）或 `a db "Hello", 00001101B, 00001010B, 0`

    - 字（word）类型：dw（16 位）

		`short int a[3]={0x1234, 0x5678, 0xABCD};` → `a dw 1234h, 5678h, 0ABCDh`

	- 双字（double word）类型：dd（32 位）
		
		`long int a[3] = {0x100, 0x200, 0x300};` → `a dd 100h, 200h, 300h`

- 数组的引用

    - 地址计算规则

        汇编中指针 q 的 q+i 表示：(unsigned int)q + i（偏移量直接加 i，不乘元素大小）。

        `b dw 1234h, 5678h, 0ABCDh`，定义了 3 个字元素，每个元素占 2 字节。按小端序存储，每个元素的低字节在低地址、高字节在高地址。

        |  值  | 12h  | 34h  | 56h  | 78h  | 0ABh | 0CDh |
        | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
        | 地址 | b+1  |  b   | b+3  | b+2  | b+5  | b+4  |

        `mov ax,b[2]`，b[2] 表示地址 b+2，又 ax 是 16 位寄存器，会访问 b+2（低字节），b+3（高字节），所以 ax 的值是 5678h。同理，`mov ax,b[1]`，ax 的值是 7812h。

    - 段寄存器设置

        `assume cs:code, ds:data`

        `mov ax, data`，`mov ds, ax`

	- 元素访问
	
		一条指令不能同时访问两个变量（如 `add c[0], c[1]` 非法，需先将 `c[1]` 存入寄存器）。

## 显卡内存

- 文本模式下，显卡内存的段地址固定为 0B800h，整个屏幕的显示内容都存储在该段内。

	每个字符占 2 字节：低地址字节存储字符的 ASCII 码（8 位），高地址字节存储字符的颜色属性（8 位，其中低 4 位为前景色，高 4 位为背景色。4 位表示 3 位 RGB 编码和 1 位亮度位）。
	
	25 行 × 80 列，屏幕上的每个位置对应的显存偏移地址计算公式为：偏移地址 = (行号 × 80 + 列号) × 2。
	
	```asm
	code segment
    assume cs:code
    main:
       mov ax, 0B800h; B800h是显卡内存的段地址
       mov ds, ax
       mov byte ptr ds:[0], 'A'; 待输出字符的ASCII码
       mov byte ptr ds:[1], 17h; 待输出字符的颜色
                               ; 高4位是背景色, 低4位是前景色
                               ; 1=蓝色背景, 7=白色前景
                               ; 1=0001      7=0111
                               ;    RGB         RGB

       mov ah, 4Ch
       int 21h
    code ends
    end main
	```

	
	
## int16h  中断

| AH   | 功能         | 输入字符   | 返回参数                   |
| :--- | :----------- | :--------- | :------------------------- |
| 00   | 读取键盘输入 | 可打印字符 | AL=按键的 ASCII 码、AH=按键扫描码 |
|      |              | 上方向键   | AL=00h、AH=48h             |
|      |              | 下方向键   | AL=00h、AH=50h             |
|      |              | 左方向键   | AL=00h、AH=4Bh             |
|      |              | 右方向键   | AL=00h、AH=4Dh             |

## 堆栈

- 堆栈是 “后进先出（LIFO）” 的内存区域，由 ss（段地址）和 sp（栈顶偏移）定位。

	注意不能直接用 `[sp]` 或 `[sp+常数或其他寄存器]` 的方式引用堆栈中的元素，需要用 bx、bp、si、di 中的某个替换。

- 定义堆栈段：
	
    ```asm
    stk segment stack  ; 必须加stack关键字，标识为堆栈段
    db 100h dup(0)     ; 堆栈大小=100h字节（256字节），无名数组。
	                   ; 此时ss指向stk堆栈段的段基址，sp=堆栈段大小=100h
    stk ends
    ```
    
    若源程序未定义 stack 段，系统会默认，ss = 程序首段的段地址（通常是代码段 cs），sp = 0（栈顶指向段起始位置）。

- 操作

	8086 仅支持 16 位堆栈操作（push/pop=2 字节），80386 + 支持 32 位（push/pop=4 字节）；在 8086 中, push 不能直接压入一个常数，在 80386 中, push 可以压入一个常数。
	
	对于 8086：

	- `push ax` 等价于：sp = sp - 2，ss:[sp] = al，ss:[sp+1] = ah
	
	- `pop ax` 等价于：al = ss:[sp]，ah = ss:[sp+1]，sp = sp + 2 
	
	注意栈顶是低地址，栈底是高地址，从栈底到栈顶，内存地址越来越小。
	
	栈顶元素低字节存 sp、高字节存 sp+1。

- 函数的调用与返回：

	对于近调用/返回（在同一代码段内）
	
    `call f` 等价于：push ip（即 call f 下一条指令的地址，方便跳转回来），然后 jmp f

    `ret` 等价于：pop ip

    （cs:ip 指向 CPU 下一条要执行的地址）

- 堆栈传递函数参数

	C 语言调用约定（__cdecl）：从右往左传参
	
	??? note "获取参数 示例"
	
        ```asm
        code segment
        assume cs:code
        ; 被调函数func内部访问参数：
        func:
            push bp            ; 保存bp
            mov bp, sp         ; 用bp作为基址访问参数
        
            ; [bp+0] = 保存的bp值
            ; [bp+2] = 返回地址IP
            ; [bp+4] = 第一个参数(ax)
            ; [bp+6] = 第二个参数(bx)
            ; [bp+8] = 第三个参数(cx)
        
            mov ax, [bp+4]     ; 获取第一个参数
            mov bx, [bp+6]     ; 获取第二个参数
            mov cx, [bp+8]     ; 获取第三个参数
        
            pop bp             ; 恢复bp
            ret                ; 返回，参数由调用者清理
        
        main:
            ; 调用者准备参数（从右到左压栈）
            push cx       ; 第三个参数（最右边）
            push bx       ; 第二个参数
            push ax       ; 第一个参数（最左边）
            call func      ; 调用函数
            add sp, 6      ; 调用者清理堆栈（3个参数×2字节=6字节）
        
            mov ah, 4Ch
            int 21h
        code ends
        end main
        ```

	??? note "局部变量的使用 示例"
        
        ```asm
        func:
            push bp
            mov bp, sp
            sub sp, 4          ; 为2个局部变量分配空间（每个2字节）
        
            ; [bp-4] = 局部变量2
            ; [bp-2] = 局部变量1
            ; [bp+0] = 保存的bp
            ; [bp+2] = 返回地址
            ; [bp+4] = 第一个参数
        
            ; 访问局部变量
            mov word ptr [bp-2], 0    ; 初始化局部变量1
            mov word ptr [bp-4], 0    ; 初始化局部变量2
        
            ; 访问参数
            mov ax, [bp+4]
        
            ; ... 函数体 ...
        
            mov sp, bp         ; 清理局部变量（恢复sp到bp）
            pop bp
            ret                ; 返回
	    ```

	??? note "用地址作函数的参数"
		```cpp
		#include <stdio.h>
        int x, y;
        int f(int a, int b, int *p)
        {
           *p = a - b;
           return a+b;
        }
        main()
        {
           y = f(8, 5, &x);
        }
        ```
        
		```asm
		data segment
        x dw 0
        y dw 0
        data ends

        code segment
        assume cs:code, ds:data
        ;input:
        ;   a=[bp+4]
        ;   b=[bp+6]
        ;   p=[bp+8]
        ;output:
        ;   *p = a-b
        ;   ax = a+b
        f:
           push bp    ; (5)
           mov bp, sp ; (*)
           mov bx, [bp+8]; bx=p=&x
           mov ax, [bp+4]; ax=a
           sub ax, [bp+6]; ax=a-b
           mov [bx], ax  ; x=*p=a-b
           mov ax, [bp+4]
           add ax, [bp+6]; ax=a+b
           pop bp    ; (6)
           ret       ; (7)
        main:
           mov ax, data
           mov ds, ax
           mov ax, offset x
           push ax; (1) 参数3
           mov ax, 5
           push ax; (2) 参数2
           mov ax, 8
           push ax; (3) 参数1
           call f ; (4)
        back:   
           add sp, 6 ; (8)
           mov y, ax ; 或写成 mov [y], ax 或写成 mov y[0], ax
                     ; 注意mov bx, ax 并不等价于 mov [bx], ax
           mov ah, 4Ch
           int 21h
        code ends
        end main
        ```


	??? note "递归 示例"

        ```asm
        code segment
        assume cs:code
        ; 每次都 n=[bp+4], ret 时 ax=f(n)
        f:
            push bp
            mov bp, sp
        
            ; [bp+0] = 保存的上层bp值
            ; [bp+2] = 返回地址IP
            ; [bp+4] = 参数n（调用时压入的）
        
            mov ax, [bp+4]
            cmp ax, 1
            je f_done
                sub ax, 1
                push ax ; 压入参数 (n-1)
                call f  ; 递归调用 f(n-1)，返回后 ax = f(n-1)
                add sp, 2   ; 清理参数 (n-1)
                add ax,[bp+4]   ; ax = f(n-1) + n = f(n)
            f_done:
                pop bp
                ret
        main:
            mov ax, 3
            push ax
            call f
            add sp, 2
            mov ah, 4Ch
            int 21h
        code ends
        end main
        ```

## 中断程序设计

- 中断：CPU 暂停当前程序，执行预设的中断处理函数，完成后返回原程序。

	中断向量：中断函数的入口地址，存放在内存 0 段，地址为 0:n*4（n 为中断号），低 2 字节 = 偏移地址，高 2 字节 = 段地址。
	
	中断指令执行流程：
	
	- `int n` 指令（触发中断）：`pushf`（不能写成 `push fl`），`push cs`，`push 下一条指令的偏移地址`，`jmp dword ptr 0:[n*4]`
	- `iret` 指令（中断返回）：`pop ip`，`pop cs`，`popf`
	
	??? example "示例"
        
        ```asm
        (1) int n指令的执行过程
        ①pushf ; pushf表示push fl
        ②push cs
        ③push 下条指令的偏移地址
        ④jmp dword ptr 0:[n*4]
        其中dword ptr 0:[n*4]称为int n的中断向量, 中断向量实质上是
        该中断对应的中断函数的地址
        设n=21h, 且有以下内存布局:
        0:84h 78h ;\ 
        0:85h 56h ; \ 1234h:5678h这个远指针存放到内存中时是按照
        0:86h 34h ; / 一个long int值0x12345678来保存的
        0:87h 12h ;/
        那么int 21h执行时, CPU会跳到1234h:5678h去执行中断函数
        
        (2) iret指令的执行过程
        ①pop ip
        ②pop cs
        ③popf
        
        (3) int8.asm
        
        ;修改int 8h的中断向量使其指向中断函数int_8h，
        ;并让该函数每隔秒1秒在屏幕左上角(0,0)处显示'0'到'9'计数
        code segment
        assume cs:code
        s db '0', 17h          ; 待显示的字符及颜色
        count db 0             ; 每隔1/18秒count++
        stop  db 0             ; stop==1时程序结束
        old_8h dw 0, 0         ; 用来保存int 8h的中断向量
        int_8h:                ; 中断函数
           push ax             ;\中断函数不能破坏任何一个寄存器的值,
           push es             ;/故需要把用到的寄存器都压入堆栈
           mov ax, 0B800h      
           mov es, ax          ; ES = 0B800h
           inc cs:[count]      ; 因每隔1/18秒自动产生一次时钟中断int 8h，
           cmp cs:[count], 18  ; 故需要累计18次中断才刚好是1秒钟
           jb skip             ; 不足18次中断就返回
           mov cs:[count], 0   ; 满18次中断后，count清零
           mov ax, word ptr cs:[s]
           mov es:[0], ax      ; 在(0,0)处显示计数
           inc cs:s[0]         ; 计数加1
           cmp cs:s[0], '9'
           jbe skip
           mov stop, 1         ; 计数超过'9'时把stop置1
        skip:
           pop es              ;\ 
           pop ax              ;/恢复寄存器的值
           push ax
           mov al, 20h         ; EOI信号(end of interrupt)
           out 20h, al         ; 20h是中断控制器的端口号
                               ; 发送20h信号给20h号端口是告诉中断控制器
                               ; 本次硬件中断已处理完毕，如果不发送此信号
                               ; 给中断控制器的话，下次再有硬件中断发生时
                               ; 中断控制器将不会放行新中断从而CPU将无法
                               ; 收到新的中断请求
           pop ax
           iret                ; 中断返回
        main:
           push cs 
           pop ds              ; DS = CS
           xor ax, ax          ; AX=0
           mov es, ax          ; ES = 0
           mov bx, 8h*4        ; int n的中断向量位于0:n*4处
           mov ax, es:[bx]     ; ax=word ptr 0:[20h]
           mov dx, es:[bx+2]   ; dx=word ptr 0:[22h]
                               ; 假设0:20h起存放有以下4个字节
                               ; 0:20h 78h
                               ; 0:21h 56h
                               ; 0:22h 34h
                               ; 0:23h 12h
           mov cs:old_8h[0], ax;\
           mov cs:old_8h[2], dx;/保存int 8h的中断向量
           cli                 ; 禁止硬件中断,防止在修改中断向量期间发生硬件中断
           mov word ptr es:[bx], offset int_8h
           mov es:[bx+2], cs   ; 修改int 8h的中断向量为code:int_8h
           sti                 ; 允许硬件中断
        wait_for_stop_signal:
           ;int 8              ; 此处可能会发生int 8h
           cmp stop, 1
           ;int 8              ; 此处可能会发生int 8h
           jne wait_for_stop_signal
           cli                 
           mov ax, cs:old_8h[0]
           mov dx, cs:old_8h[2]
           mov es:[bx], ax     ;\
           mov es:[bx+2], dx   ;/恢复int 8h的中断向量
           sti
           mov ah, 4Ch
           int 21h
        code ends
        end main
        ```
