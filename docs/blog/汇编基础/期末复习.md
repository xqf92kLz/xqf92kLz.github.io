## 基础知识

- 显存地址空间：[A000:0000, B000:FFFF]。其中，图形模式：[A000:0000, A000:FFFF]，文本模式：[B800:0000, B800:7FFF]。

	每个字符占 2 字节：低地址字节存储字符的 ASCII 码（8 位），高地址字节存储字符的颜色属性（8 位，其中低 4 位为前景色，高 4 位为背景色。4 位表示 3 位 RGB 编码和 1 位亮度位）。

	25 行 × 80 列，屏幕上的每个位置对应的显存偏移地址计算公式为：偏移地址 = (行号 × 80 + 列号) × 2。

- 数制

	二进制：后缀 B 或 b
	
	八进制：后缀 Q 或 q
	
	十进制：无需后缀
	
	十六进制：后缀 H 或 h，若最高位是字母还需加前缀 0


## 数据访问

### 寄存器

- 8086：ax、bx、cx、dx、sp、bp、si、di、cs、ds、es、ss、ip、fl，宽度为 16 位

	80386：eax、ebx、ecx、edx、esp、ebp、esi、edi、cs、ds、es、ss、eip、efl，段寄存器仍为 16 位，其余寄存器军扩展至 32 位
	
	如果在 8086 汇编程序中使用 32 位的寄存器，需要在开头 `.386`，并且 `data segment use16` 来保证偏移地址仍然是 16 位的
	
- 通用寄存器：ax，bx，cx，dx

	ax 的低 8 位为 al，高 8 位为 ah；eax 的低 16 位为 ax。bx，cx，dx 同理。
	
	单独使用 al 运算时，al 和 ah 被视为两个独立的寄存器，溢出的高位不会被保存在 ah 中。

- 段寄存器：表示段地址

	cs：代码段寄存器，存放代码段的地址
	
	ds：数据段寄存器，存放数据段的段地址
	
	es：附加段寄存器
	
	ss：堆栈段寄存器，存放堆栈段的段地址
	
	cs 不能用 mov 指令赋值；ds、es、ss 可以用 mov 指令赋值，但源操作数不能是常数，只能是寄存器 ax、bx、cx、dx、sp、bp、si、di 或变量（word）

- 偏移地址寄存器：表示偏移地址

	ip：与 cs 搭配使用，`cs:ip` 指向当前将要执行的指令。该寄存器不能直接出现在任何指令中
	
	sp：与 ss 搭配使用，`ss:sp` 指向堆栈顶端。不能放在 `[]` 内用于间接寻址
	
	bx（通用寄存器）、bp、si、di：可以放在 `[]` 内用于间接寻址，还可以参与算术、逻辑、移位运算

- 标志寄存器：存储标志位

	fl：不能直接出现在指令中，但可以 `pushf`、`popf`。它的意义在于它的各个位
	
	1. 6 个状态标志：反映当前指令的执行情况，cf、zf、sf、of、pf、af
	
        - （第 0 位）cf：两数相加（不包括 `inc` 指令）产生进位、两数相减（不包括 `dec` 指令）产生借位、两数相乘的乘积宽度超过被乘数宽度、移位指令最后移出的那一位为 1 时，cf = 1，否则 cf = 0

            相关指令：`jc`、`jnc`、`clc`、`stc`、`cmc`、`adc`


        - （第 6 位）zf：运算结果为 0 时，zf = 1，否则 zf = 0
    
            相关指令：`jz` / `je`、`jnz` / `jne`
    
        - （第 7 位）sf：运算结果为正时 sf = 0，为负时 sf = 1
    
            相关指令：`js`、`jns`
    
        - （第 11 位）of：两个正数相加变成负数、两个负数相加变成正数、两数相乘的乘积宽度超过被乘数宽度、移位前后最高位发生改变时，of = 1，否则 of = 0
    
            相关指令：`jo`、`jno`
    
        - （第 2 位）pf：当运算结果低 8 位中 1 的个数为偶数时，pf = 1，否则 pf = 0
    
            相关指令：`jp` / `jpe`、`jnp` / `jpo`
    
        - （第 4 位）af：加法时低 4 位向高 4 位进位、减法时低 4 位向高 4 位借位时，af = 1，否则 af = 0
    
    2. 3 个控制标志：控制 CPU，df、if、tf

        - （第 10 位）df：控制字符串操作指令的运行方向

            df = 0 表示字符串操作指令按正向（从低到高）运行，即每次操作后 si、di 递增；df = 1 表示字符串操作指令按反向（从高到低）运行，即每次操作后 si、di 递减

            相关指令：`cld`、`std`、`movsb`、`movsw`

        - （第 9 位）if：控制硬件中断

            if = 0 表示禁止硬件中断，if = 1 表示允许硬件中断

            相关指令：`cli`、`sti`

        - （第 8 位）tf：设置 CPU 的运行模式，与调试相关

            tf = 0 表示常规模式，连续执行指令；tf = 1 表示单步模式，每执行一条指令后都会跟随执行 `int 01h` 中断指令，用于调试
    
    3. 7 个保留位

### 内存

- 小端规则
- 物理地址与逻辑地址

	DOS 系统运行在 CPU 的实模式 (real mode) 下，可访问的内存共有 1MB，地址范围为 [00000h, 0FFFFFh]，这样用 20 位表示的地址称为物理地址
	
	寻址时使用的是 段地址 : 偏移地址 形式的逻辑地址。段地址和偏移地址是两个 16 位的地址，物理地址 = 段地址 × 10h + 偏移地址
	
	- 偏移地址：可以用常数表示。`offset 变量名或标号名` 表示变量或标号的偏移地址。
	- 段地址：不能用常数表示，只能用段寄存器表示。`seg 变量名或标号名` 或 `段名` 表示变量或标号的段地址。
	- 段：20 位段首地址的低 4 位为 0，每个段的最大长度 = 10000h 字节，即 64KB。

- 寻址方式
	
	- 立即数方式：即操作数为常数
	- 寄存器方式：以寄存器为操作数
	- 直接寻址：通过逻辑地址表示操作数，且偏移地址为立即数，比如 [1234h]、ss:[1234h]，省略情况默认 ds
	- 间接寻址：逻辑地址的偏移地址以间接形式表示，`[]` 内只能是 bx、bp、si、di，且表示为 基址寄存器（bx、bp 选其一或没有）+ 变址寄存器（si、di 选其一或没有）+ 位移量（立即数或没有）的形式，即 bx、bp 不能同时出现，si、di 不能同时出现。

		省略段地址时，如果偏移地址内有 bp 出现，则缺省段地址为 ss，其它情况均为 ds
	
- 变量定义

	一般情况下变量在数据段中被定义，根据变量的定义位置来决定段地址和偏移地址

	`变量名 类型 初始值`，类型有 db、dw、dd 等
	
	`变量名 类型 重复次数 dup(重复项)` 用于生成重复的数据

- 数据宽度

	`byte ptr`、`word ptr`、`dword ptr`

### 栈

- 在空栈中，`ss:sp` 指向栈空间最高地址单元的下一个单元

- 栈顶是低地址，栈底是高地址

    push ax 等价于：sp = sp - 2，ss:[sp] = al，ss:[sp+1] = ah

    pop ax 等价于：al = ss:[sp]，ah = ss:[sp+1]，sp = sp + 2
    
### 端口

- 端口地址仅有 16 位偏移地址，没有段地址，取值范围为 [0000h, 0FFFFh]。

	`in al,port`：`al=[port]`
	
	`in ax,port`：`al=[port]`，`ah=[port+1]`
	
	`out port,al`：`[port]=al`
	
	`out ax,port`：`[port]=al`，`[port+1]=ah`

- 常用的端口号：

	70h 和 71h：分别是 CMOS RAM 的地址端口和数据端口，因此访问 CMOS RAM 时需要同时处理这两个端口的信号
	
	60h：键盘输入

## 汇编程序

- 段
- 假设

	“建立关联”意味着并不是将段地址直接赋值给段寄存器，而是提醒编译器在编译时将段地址替换为关联的段寄存器。
	
	`assume ds:data` 外，若想在程序中正确引用数据段内的变量或数据元素，必须在代码段一开始对 ds 进行以下赋值：`mov ax,data`，`mov ds,ax`

- 语句
- 常数
- 标号

## 8086 指令系统

任何指令均不能引用寄存器 ip 及 fl

操作数：常数（idata），寄存器（reg），内存变量（mem）

- 指令结构
- 数据传送指令

	- 通用数据传送指令
		
		均不影响任何标志位
		
		- `mov dest src`：格式 `mov reg,reg|idata|mem`，`mov mem,idata|reg`（不能 `mov mem,mem`）。不能 `mov 段寄存器 常数|段寄存器`，不能 `mov cs ...`
		
		- `push op`：格式 `push reg16|mem16|reg32|mem32`
		
		- `pop op`：格式 `pop reg16|mem16|reg32|mem32`
		
		- `xchg op1 op2`：格式 `xchg reg,reg|mem`，`xchg mem,reg`（不能 `xchg mem,mem`），且不能 `xchg 段寄存器 ...` 或 `xchg ... 段寄存器`
	
	- 端口输入输出指令
	
		- `in acc,port`：格式 `in al|ax,idata|dx`，且 idata 在 [00h,0FFh] 中，dx 在 [0000h,0FFFFh] 中
		
		- `out port,acc`：格式 `out idata|dx,al|ax`，且 idata 在 [00h,0FFh] 中，dx 在 [0000h,0FFFFh] 中
	
	- 地址传送指令
	
		- `lea dest,src`：dest = offset src，格式 `lea reg,mem`
		
		- `lds dest,src`：dest = word ptr [src]，ds = word ptr [src+2]，格式 `lds reg,mem32`，其中 src 中保存的是远指针，形如 src dw offset xyz,seg xyz
		
		- `les dest,src`：dest = word ptr [src]，es = word ptr [src+2]，格式 `les reg,mem32`
		
	- 标志寄存器传送指令
	
		- `lahf`：ah = fl & 0FFh，将 fl 低 8 位复制到 ah
		- `sahf`：fl = (fl & 0FF00h) | 2 | (ah & 0D5h)，将 ah 存入 fl 低 8 位，且只保留 ah 的 0 2 4 6 7 位（cf pf af zf sf），且第 1 位恒为 1
		- `pushf`：sp = sp - 2，word ptr ss:[sp] = fl
		- `popf`：fl = word ptr ss:[sp]，sp = sp + 2
		- `pushfd`：sp = sp - 4，dword ptr ss:[sp] = efl
		- `popfd`：efl = dword ptr ss:[sp]，sp = sp + 4
	
- 转换指令
	- `cbw`：将 al 符号扩充到 ax
	- `cwd`：将 ax 符号扩充到 dx:ax
	- `cdq`：将 eax 符号扩充到 edx:eax
	- `movsx dest,src`：格式 `movsx reg16,reg8|mem8`，`movsx reg32,reg8|mem8|reg16|mem16`，将 src 符号扩充到 dest
	- `movzx dest,src`：格式 `movzx reg16,reg8|mem8`，`movzx reg32,reg8|mem8|reg16|mem16`，将 src 领扩充到 dest
	- `xlat`：al = byte ptr ds:[bx+al]

- 算术运算指令
	
	- 加法指令
        - `add dest,src`
        - `inc op`：不影响 cf
        - `adc dest,src`：dest += src + cf
	- 减法指令
		- `sub dest,src`
		- `sbb dest,src`：dest = dest - src - cf
		- `dec op`：不影响 cf
		- `neg op`：op = - op
		- `cmp op1,op2`，temp = op1 - op2
	- 乘法指令
		- `mul src`：格式 `mul reg|mem`
		
			`imul src`：格式 `imul reg|mem`
		
			```cpp
			if(sizeof(src)==1) ax=al*src;
			else if(sizeof(src)==2) dx:ax=ax*src;
			else if(sizeof(src)==4) edx:eax=eax*src;
			```
	
	- 除法指令
	
		- `div op`：格式 `div reg|mem`
		
			`idiv op`：格式 `idiv reg|mem`
			
			若除数为 0 或保存商的寄存器无法容纳商时都会发生除法溢出，此时 CPU 会在除法指令上方插入并执行一条 int 00h 指令
		
			```cpp
			if(sizeof(op)==1) al=ax/op,ah=ax%op;
			else if(sizeof(op)==2) ax=dx:ax/op,dx=dx:ax%src;
			else if(sizeof(op)==4) eax=edx:eax/op,edx=edx:eax%op;
			```
	
	- 浮点运算指令
	
- 十进制调整指令

	BCD 码 (Binary Coded Decimal)：用二进制编码的十进制数，分为压缩 BCD 码和非压缩 BCD 码。例如十进制数 37 用压缩 BCD 码表示为 37h，而用非压缩 BCD 码则表示为 0307h
	
	- 压缩 BCD 码调整指令
	
		- `daa`：在 al 被做加法后将结果 al 调整为 BCD 码
		- `das`：在 al 被做减法后将结果 al 调整为 BCD 码
	- 非压缩 BCD 码调整指令
	
		- `aaa`：加法的 ASCII 调整，在 al 被做加法后连带 ah 一起调整 ax 为非压缩 BCD 码
		- `aas`：减法的 ASCII 调整，在 al 被做减法后连带 ah 一起调整 ax 为非压缩 BCD 码
		- `aam`：乘法的 ASCII 调整，在 al 被做乘法后连带 ah 一起调整 ax 为非压缩 BCD 码
		- `aad`：除法的 ASCII 调整，在 al 被做除法后连带 ah 一起调整 ax 为非压缩 BCD 码

- 逻辑运算和移位指令
	- 逻辑运算
	
		- `and dest,src`
		- `or dest,src`
		- `xor dest,src`
		- `not op`：op = ~op
		- `test dest,src`：temp = dest & src
	
	- 移位指令
        - `shl dest,count`：对 dest 逻辑左移 count 位，右侧补 0，左侧最后溢出的一位落入 cf。格式 `shl reg|mem,idata|cl`，若无 .386 则 idata 只能为 1
        - `shr dest,count`：对 dest 逻辑右移 count 位，左侧补 0，右侧最后溢出的一位落入 cf
        - `sal dest,count`：对 dest 算数左移 count 位，同逻辑左移
        - `sar dest,count`：对 dest 算数右移 count 位，左侧补符号位，右侧最后溢出的一位落入 cf
        - `rol dest,count`：对 dest 循环左移 count 位，最高位回到最低位同时移到 cf 中
        - `ror dest,count`：对 dest 循环右移 count 位，最低位回到最高位同时移到 cf 中
        - `rcl dest,count`：带进位循环左移，即 cf 加在 dest 左侧一起循环左移
        - `rcr dest,count`：带进位循环右移，即 cf 加在 dest 右侧一起循环右移

- 字符串操作指令

	rep：把后面的字符串操作指令重复 cx 次
	
	repe / repz：最多重复 cx 次，且仅当比较相等时继续重复
	
	repne / repnz：最多重复 cx 次，且仅当比较不相等时继续重复
	
	- 字符串复制指令
	
        - `movsb` / `rep movsb`：以字节为单位从 ds:[si] 传送数据到 es:[di]，并移动 si di。si di 的移动与 df 有关，预先用 cld std 设置，df=0 则 si di 移向下一个字节，df=1 移向上一个

            ```cpp
            //movsb:
            byte ptr es:[di]=byte ptr ds:[si];
            if(df==0) si++,di++;
            else si--,di--;
            //rep movsb:
            again:
                if(cx==0) goto done;
                byte ptr es:[di]=byte ptr ds:[si];
                if(df==0) si++,di++;
                else si--,di--;
                cx--;
                goto again;
            done:
            ```

        - `movsw` / `rep movsw`：以字为单位从 ds:[si] 传送数据到 es:[di]，并移动 si di

            ```cpp
            //movsw:
            word ptr es:[di]=word ptr ds:[si];
            if(df==0) si+=2,di+=2;
            else si-=2,di-=2;
            ```

        - `movsd` / `rep movsd`：以双字为单位从 ds:[si] 传送数据到 es:[di]，并移动 si di

            ```cpp
            //movsd:
            dword ptr es:[di]=dword ptr ds:[si];
            if(df==0) si+=4,di+=4;
            else si-=4,di-=4;
            ```
	
	- 字符串比较指令
	
		- `cmpsb` / `repe cmpsb` / `repne cmpsb`：比较字节 ds:[si] 与 es:[di]，即 byte ptr ds:[si] - byte ptr es:[di] 丢弃结果保留标志位，并移动 si di
		
		- `cmpsw` / `repe cmpsw` / `repne cmpsw`：比较字 ds:[si] 与 es:[di]，即 word ptr ds:[si] - word ptr es:[di] 丢弃结果保留标志位，并移动 si di

		- `cmpsd` / `repe cmpsd` / `repne cmpsd`：比较双字 ds:[si] 与 es:[di]，即 dword ptr ds:[si] - dword ptr es:[di] 丢弃结果保留标志位，并移动 si di
			
	- 搜索字符串指令
	
		- `scasb` / `repe scasb` / `repne scasb`：比较 al 与 es:[di]，即计算 al - es:[di] 丢弃结果保留符号位，并移动 di
		- `scasw` / `repe scasw` / `repne scasw`：比较 ax 与 es:[di]，即计算 ax - es:[di] 丢弃结果保留符号位，并移动 di
		- `scasd` / `repe scasd` / `repne scasd`：比较 eax 与 es:[di]，即计算 eax - es:[di] 丢弃结果保留符号位，并移动 di
	
	- 写入字符串指令
	
		- `stosb` / `rep stosb`：把字节 al 存入 es:[di] 中，并移动 di
		- `stosw` / `rep stosw`：把字 ax 存入 es:[di] 中，并移动 di
		- `stosd` / `rep stosd`：把双字 eax 存入 es:[di] 中，并移动 di
	
	- 读取字符串指令
	
		- `lodsb`：从 ds:[si] 读取一个字节存入 al，并移动 si
		- `lodsw`：从 ds:[si] 读取一个字存入 ax，并移动 si
		- `lodsd`：从 ds:[si] 读取一个字存入 eax，并移动 si

- 控制转移指令

	- 无条件跳转指令
	
		- `jmp short dest` / `jmp dest`：短跳。机器码有 2 个字节，dest 与下条指令距离在 [-128,127]
		- `jmp near ptr dest` / `jmp dest`：近跳。机器码有 3 个字节，dest 与下条指令距离在 [-32768,+32767]
		- `jmp far ptr dest` / `jmp dest`：远跳。机器码有 5 个字节
	
	- 条件跳转指令
	
		这些跳转都是短跳，dest 与下条指令偏移地址距离在 [-128, 127]
		
		`jc`，`jnc`，`jz`，`jnz`，`js`，`jns`，`jo`，`jno`，`jp`，`jnp`，`jcxx`，`jecxz`
		
		`ja`，`jb`，`jae`，`jbe`，`jg`，`jl`，`jge`，`jle`，`jz`
	
	- 循环指令
	
		- `loop dest`：cx 表示循环次数，cx 先减 1，如果 cx != 0 则跳转到 dest
		
			loop 属于短跳，需要目标地址与下条指令偏移地址距离在 [-128, 127] 内
			
			loop 前令 cx = 0 能达到最大循环次数 10000h。如果不希望 cx == 0 时进入循环，那么应该在进入循环前用 jcxz 指令跳到循环出口
		
		- `loopz dest` / `loope dest`：先 cx 减 1（此处不影响标志位），然后如果 cx != 0 且 zf == 1 则跳转到 dest
		- `loopnz dest`：先 cx 减 1（此处不影响标志位），然后如果 cx != 0 且 zf == 0 则跳转到 dest
	
	- 子程序调用与返回指令
	
		- `call near ptr dest` / `call dest`：近调用。机器码有 3 个字节
		- `retn` / `retn idata16`：近返回（在多数情况下可以简写为 ret）
		- `call far ptr dest`：远调用。机器码有 5 个字节
		- `retf` / `retf idata16`：远返回
	
	- 中断和中断返回指令
	
		- `int idata8`：调用 n 号中断，等效的操作有 pushf, push cs, push ip, tf = 0, if = 0, ip = word ptr 0:[n\*4], cs = word ptr 0:[n\*4+2]
		
		- `into`：溢出中断，如果 of == 1 则调用 4 号中断（int 4h）
		- `iret`：中断返回，等效操作有 pop ip, pop cs, popf
		
		
			