### 有符号数与无符号数

- **有符号数：**具有符号位，用于表示正数和负数。在计算机中通常采用补码（two's complement）形式存储。

    - 补码定义：$x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$

        ??? info

            - 原码：最高位为符号位，其余为数值位。
            
            - 反码：正数反码 = 原码；负数反码 = 原码符号位不变、数值位取反。
            
                $x_{反码}=\begin{cases}x&(x\geq 0)\\2^n-1-|x|&(x<0)\end{cases}$
            
            - 补码：正数补码 = 原码；负数补码 = 反码 + 1。
            
                $x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
            
                性质：设 $a,b>0$，$a_{补码}+(-b)_{补码}=a+(2^n-b)\equiv a-b\pmod {2^n}$。
            
                因此补码不仅统一了 $+0$ 与 $-0$，也实现了加法与减法的统一。

    - 由补码求真值：$x=\begin{cases}x_{补码}&(0\leq x_{补码}<2^{n-1})\\x_{补码}-2^n&(2^{n-1}\leq x_{补码}<2^n)\end{cases}$

        $n$ 位补码的表示范围：$[-2^{n-1},2^{n-1}-1]$，其中非负数范围为 $[0,2^{n-1}-1]$，负数范围为 $[-2^{n-1},-1]$。

- **无符号数：**无符号位，均为数值位。表示范围：$[0,2^n-1]$。

```asm
              ; (1)十六进制常数末尾要添加h或H后缀
mov ax, 1     ; (2)若十六进制常数恰好以字母开头, 则需要添加0前缀
mov bx, 0FFFFh; 这里0FFFFh是汇编语言的十六进制常数，相当于C语言的0xFFFF（并不是说高位为0）
cmp ax, bx
jb done       ; jb表示jump if below, 是指非符号数的小于则跳
              ; 这里会跳转, 因为 1 < 65535
              ; 非符号数的大于则跳指令为ja，意为jump if above

㈣ 在汇编语言中如何对两个符号数(用补码表示的正、负数)做比较并跳转？
              ; (1)十六进制常数末尾要添加h或H后缀
mov ax, 1     ; (2)若十六进制常数恰好以字母开头, 则需要添加0前缀
mov bx, 0FFFFh; 这里0FFFFh是汇编语言的十六进制常数，
              ; 相当于C语言的0xFFFF
cmp ax, bx
jl done       ; jl表示jump if less, 是指符号数的小于则跳
              ; 这里不会跳转, 因为 1 > -1
              ; 符号数的大于跳转指令为jg，意为jump if greater
```

### 运算

**算术运算：**

- `+`：`add`

    ```asm
    mov ax, 3
    mov bx, 2
    add ax, bx; ax=ax+bx=3+2=5
    ```

- `-`: `sub`

    ```asm
    mov ax, 3
    mov bx, 2
    sub ax, bx; ax=ax-bx=3-2=1
    ```

- `*`：`imul`（有符号），`mul`（无符号）

	```asm
	mov ax, 3
    mov bx, 2
    imul ax, bx; ax=ax*bx=3*2=6
	```

- `/`：`idiv`（有符号），`div`（无符号）
	
    ```asm
    mov dx, -1; 相当于mov dx, 0FFFFh
    mov ax, -6; 相当于mov ax, 0FFFAh
              ; dx与ax组合起来就是0FFFFFFFAh, 它就是32位的-6  
    mov bx, 2 ; 当除数为16位的寄存器或变量时，被除数一定是=dx（高 16 位）:ax（低 16 位）
    idiv bx   ; ax=商=-3=0FFFDh, dx=余数=0=0000h
    ```
    
    ```asm
	;计算100/16的商和余数
    code segment
    assume cs:code
    main:
       mov dx, 0
       mov ax, 100; dx和ax合起来表示32位的100
       mov bx, 16
       div bx     ; ax=商, dx=余数
    done:   
    code ends
    end main
    ```
    
    | 数据宽度            | 被除数    | 商（结果） | 余数（结果） |
    | ------------------- | --------- | ---------- | ------------ |
    | 8 位除法            | `AX`      | `AL`       | `AH`         |
    | 16 位除法           | `DX:AX`   | `AX`       | `DX`         |
    | 32 位除法           | `EDX:EAX` | `EAX`      | `EDX`        |
    | 64 位除法（x86-64） | `RDX:RAX` | `RAX`      | `RDX`        |

**关系运算：**

- `==`：`je`
- `!=`：`jne`
- `>`：有符号数 `jg`，无符号数 `ja`
- `<`：有符号数 `jl`，无符号数 `jb`

    ```asm
    mov ax, -1; 相当于mov ax, 0FFFFh
    mov bx, 2
    cmp ax, bx
    jl ax_is_less_than_bx; jl会跳转（因为-1<2）, 若改成jb则不会跳转（因为 65535>2）

    ax_is_less_than_bx:
    ```

- `>=`：有符号数 `jge`，无符号数 `jae`
- `<=`：有符号数 `jle`，无符号数 `jbe`

逻辑运算：

- `&&`
- `||`
- `!`

### 条件

??? example "课堂示例"

    ??? note "max2"
    
        ```asm
        ;求ax、bx的最大值并保存到cx中
        comment #
        if(ax > bx)
           cx = ax;
        else
           cx = bx;
           16位非符号数的取值范围[0000h, 0FFFFh]即[0,65535]
           16位的正符号数的取值范围[0000h, 7FFFh]即[0,32767]
           16位的负符号数的取值范围[8000h, 0FFFFh]即[-32768, -1]
        #
        code segment
        assume cs:code
        main:
           mov ax, 2
           mov bx, 3
           cmp ax, bx
           ja ax_is_bigger ;当ax及bx的值均<=7FFFh时, ja、jg均可用来表示大于则跳
        bx_is_bigger:
           mov cx, bx
           jmp done
        ax_is_bigger:
           mov cx, ax
        done:   
        code ends
        end main
        ```
    
    ??? note "max3"
    
        ```asm
        ;求ax、bx、cx的最大值并保存到dx中
        comment #
        if(ax > bx)
           if(ax > cx)
              dx = ax;
           else
              dx = cx;
        else
           if(bx > cx)
              dx = bx;
           else
              dx = cx;   
        #
        code segment
        assume cs:code
        main:
           mov ax, 2
           mov bx, 5
           mov cx, 3
           cmp ax, bx
           jg ax_g_bx
        bx_ge_ax:
           cmp bx, cx
           jg bx_g_cx
        cx_ge_bx:
           mov dx, cx
           jmp done
        bx_g_cx:
           mov dx, bx
           jmp done
        ax_g_bx:
           cmp ax, cx
           jg ax_g_cx
        cx_ge_ax:
           mov dx, cx
           jmp done
        ax_g_cx:
           mov dx, ax
        done:   
        code ends
        end main
        ```

### 循环

??? example "课堂示例"

    ??? note "cmp"
        ```asm
        ;编程计算ax=3+2+1+0
        code segment
        assume cs:code
        main:
           mov ax, 0
           mov bx, 3
        again:   
           add ax, bx
           sub bx, 1 ; bx = bx - 1 
           cmp bx, 0
           jl  done  ; 这里必须用jl(符号数的小于则跳,是jg的反义词)，
                     ; 不能改成jb(非符号数的小于则跳,是ja的反义词)，
                     ; 因为当bx=0-1=0FFFFh时，
                 ; 它作为非符号数理解，其值为65535，
                 ; 而它作为符号数理解，其值为-1，故
                 ; 这里若改用jb done的话，则这个跳转
                 ; 永远不会发生，因为任何一个[0000h, 0FFFFh]
                 ; 范围的非符号数均不可能小于0
           jmp again
        done:
    
        code ends 
        end main
        ```
    
    ??? note "cmp2"
        ```asm
        ;编程计算ax=32766+32767+32768(忽略进位)
        code segment
        assume cs:code
        main:
           mov ax, 0
           mov bx, 7FFEh; ax=32766
        again:   
           add ax, bx   ; ①ax=0+7FFEh ②ax=7FFEh+7FFFh ②ax=7FFEh+7FFFh+8000h
           add bx, 1    ; ①bx=7FFFh ②bx=8000h ③bx=8001h
           cmp bx, 8000h
           ja done      ; 这里必须用ja，不能用jg
                        ; 因为cmp bx, 8000h指令中的8000h有两个
                    ; 身份，当它被看作符号数时，其值是一个负数
                    ; 且等于-32768，而当它被看作非符号数时，其值是
                    ; 一个正整数，且等于32768，一旦我们改用jg done
                        ; 来跳转，那么当bx=7FFF时，CPU会认为bx与8000h
                ; 的比较是符号数的比较，即bx=32767，8000h=-32768，
                ; 而32767 > -32768，于是jg done会跳转，从而造成
                ; 循环提前结束，当程序运行到done时，ax=7FFEh，
                ; 而我们本来希望程序运行到done时，ax=7FFEh+7FFFh+8000h
                ; =7FFDh
           jmp again
        done:
        code ends 
        end main
        ```
    
    ??? note "fact"
        ```asm
        ;计算1! + 2! + 3!
        comment #
            cx   bx dx ax
        int i=1, x, j, sum=0;
        while(i<=3)
        {
           x = 1;
           j = 1;
           while(j<=i)
           {
              x = x * j;
              j = j + 1;
           }
           sum = sum + x;
           i = i + 1;
        }
        #
        .386              ; .386告诉编译器后续会(1)用到386指令, 
                          ; (2)使用32位地址
        code segment use16; use16表示仍旧采用16位地址, 即取消(2)选项
        assume cs:code
        main:
           mov ax, 0; sum=0
           mov cx, 1; i
        again:   
           cmp cx, 3
           ja done
           mov bx, 1; x
           mov dx, 1; j
        fact_next:   
           cmp dx, cx
           ja fact_done
           imul bx, dx; bx=bx*dx
           add dx, 1
           jmp fact_next
        fact_done:   
           add ax, bx
           add cx, 1
           jmp again
        done:   
        code ends
        end main
        ```

```asm
comment #
for(int i=l1;i<=r1;i++)
	for(int j=l2;j<=r2;j++)
		for(int k=l3;k<=r3;k++)
			循环体操作
#

;for 式
code segment
assume cs:code
main:
mov ax,[l1]
outer_loop:
	cmp ax,[r1]
	jg exit_outer
	mov bx,[l2]
	middle_loop:
		cmp bx,[r2]
		jg exit_middle
		mov cx,[l3]
		inner_loop:
			cmp cx,[r3]
			jg exit_inner
			; 循环体操作
			add cx,1
			jmp inner_loop
		exit_inner:
		add bx,1
		jmp middle_loop
	exit_middle:
	add ax,1
	jmp outer_loop
exit_outer:
code ends
end main

;do-while 式（感觉写起来更清楚）
code segment
assume cs:code
main:
mov ax,[l1] 
outer_loop:
	mov bx,[l2]
	middle_loop:
		mov cx,[l3]
		inner_loop:
			; 循环体操作
			add cx,1
			cmp cx,[r3]
			jle inner_loop     
		add bx,1
		cmp bx,[r2]
		jle middle_loop 
	add ax,1
	cmp ax,[r1]
	jle outer_loop
code ends
end main
```

### 输出

```asm
code segment
assume cs:code
main:
   mov ah, 2  ; ah=2表示调用int 21h函数集中的2号功能
              ; 同样, AH是ax的高8位, AL则是ax的低8位
   mov dl, 'A'; DL=待输出的符号, DL是dx的低8位
              ; DH则是dx的高8位
   int 21h; 相当于调用一个函数, int表示中断(interrupt)
code ends
end main
```

???+ example "课堂示例"

    ??? note "用双重循环输出3行星号, 每行5个星号"
    
        ```asm
        ; 用双重循环输出3行星号, 每行5个星号
        ; ***** 
        ; *****
        ; *****
        code segment
        assume cs:code
        main:
           mov bx, 3; 行数
              ;editplus中选中几行，再按ctrl+i右缩进, ctrl+shift+i左缩进
              ;缩进空格数可以通过菜单Tools->Preferences->File->Settings & Syntax->asm->Tab/indent->Tab size修改
        next_row:      
              mov cx, 5  ; 每行5个*
           again:
              mov ah, 2  ; AH的值用来规定int 21h的子功能号
              mov dl, '*'; DL用来表示待输出的字符
              int 21h    ; 调用DOS函数集
              sub cx, 1
              jnz again  ; 若不等于0则跳到again
              mov ah, 2
              mov dl, 0Dh; 回车符的ASCII码
              int 21h    ; putchar('\r');
              mov ah, 2
              mov dl, 0Ah; 换行符的ASCII码
              int 21h    ; putchar('\n');
           sub bx, 1
           jnz next_row
        code ends
        end main
        ```
    
    ??? note "把eax中的32位整数转化成16进制格式并输出"
    
        ```asm
        ;把eax中的32位整数转化成16进制格式并输出
        .386
        code segment use16
        assume cs:code
        main:
           mov eax, 8086BEEFh
           mov cx, 8
        again:   
           rol eax, 4   ; 把eax循环左移4位, eax=086BEEF8h
           mov ebx, eax ; 备份eax的当前值
           and eax, 0Fh ; mask = 0000 0000 0000 0000 0000 0000 0000 1111
                        ; eax = eax & 0xF
           cmp eax, 10  
           jge is_alpha
        is_digit:
           add eax, '0' ; 0+'0'->'0', 9+'0'->'9'
           jmp output
        is_alpha:
           sub eax, 10
           add eax, 'A' ; 10-10+'A'->'A', 15-10+'A'->'F'
        output:   
           mov ah, 2
           mov dl, al
           int 21h
           mov eax, ebx ; 从备份中恢复eax的值
           sub cx, 1
           jnz again
           mov ah, 4Ch
           mov al, 0
           int 21h
        code ends
        end main
        ```



[常见中断](https://blog.csdn.net/Zach_z/article/details/78576216) `int 21h`：（[中断大全](https://www.uwouni.com/rbrown.htm)）

| AH   | 功能           | 调用参数         | 返回参数    |
| ---- | -------------- | ---------------- | ----------- |
| 00   | 程序终止       | CS=程序段前缀    |             |
| 01   | 键盘输入并回显 |                  | AL=输入字符 |
| 02   | 显示输出       | DL=输出字符      |             |
| 09   | 显示字符串     | DS:DX=字符串地址 |             |
| 4C   | 带返回码结束   | AL=返回码        |             |

### 函数

```asm
;输出3层金字塔
;   *    空格个数=行数-1-行号, 星号个数=行号*2+1
;  ***
; *****
code segment
assume cs:code
output_cr:    ; 用标号来命名一个函数
   mov ah, 2
   mov dl, 0Dh; 回车符的ASCII码
   int 21h    ; putchar('\r');
   mov ah, 2
   mov dl, 0Ah; 换行符的ASCII码
   int 21h    ; putchar('\n');
   ret        ; 函数返回
   
output_space: ; 输出bp个空格
   cmp bp, 0
   je output_space_done
   mov ah, 2
   mov dl, ' '
   int 21h
   sub bp, 1
   jmp output_space
output_space_done:   
   ret
   
output_star: ; 输出bp个*
   mov ah, 2
   mov dl, '*'
   int 21h
   sub bp, 1
   jnz output_star
   ret
   
output_a_row:
   mov bp, bx
   sub bp, 1
   sub bp, si; bp = bx-1-si = 空格数量
   call output_space
   mov bp, si
   add bp, bp
   add bp, 1; bp = si * 2 + 1 = 星号的个数
   call output_star
   call output_cr             
   ret 
   
main:
   mov bx, 3; 行数
   mov si, 0; 初始行号
next_row:   
   call output_a_row
   add si, 1
   cmp si, bx
   jl next_row
   mov ah, 4Ch ;\ 若在汇编程序中删除这3句话, 则编译出来的exe只能用TD调试, 不能
   mov al, 0   ; \在命令行中输入程序名运行, 若强行运行，则会因为CPU执行后续内存空间中的垃圾代码而死机。
   int 21h     ;/ 这3句话相当于C语言中调用函数exit(0), 用于结束程序的运行。
code ends
end main
```

