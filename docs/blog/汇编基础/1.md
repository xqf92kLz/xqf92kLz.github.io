模板：

```asm
.386
data segment use16
data ends
code segment use16
assume cs:code,ds:data
main:

   mov ah, 4Ch
   mov al, 0
   int 21h
code ends
end main
```

### 数据的表示与运算

- 数据的表示

    - 有符号数与无符号数

        - 有符号数：具有符号位，用于表示正数和负数。用补码存储。
        
        	表示范围：$[-2^{n-1},2^{n-1}-1]$，其中非负数范围为 $[0,2^{n-1}-1]$，负数范围为 $[-2^{n-1},-1]$。
			
			??? abstract "补码"
			
                - 补码定义：$x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
                
                    ??? info
                
                        - 原码：最高位为符号位，其余为数值位。
                
                        - 反码：正数反码 = 原码；负数反码 = 原码符号位不变、数值位取反。
                
                            $x_{反码}=\begin{cases}x&(x\geq 0)\\2^n-1-|x|&(x<0)\end{cases}$
                
                        - 补码：正数补码 = 原码；负数补码 = 反码 + 1。
                
                            $x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
                
                            性质：设 $a,b>0$，$a_{补码}+(-b)_{补码}=a+(2^n-b)\equiv a-b\pmod {2^n}$。
                
                            因此补码不仅统一了 $+0$ 与 $-0$，也实现了加法与减法的统一。
                
                - 由补码求真值：$x=\begin{cases}x_{补码}&(0\leq x_{补码}<2^{n-1})\\x_{补码}-2^n&(2^{n-1}\leq x_{补码}<2^n)\end{cases}$

        - 无符号数：无符号位，均为数值位。
        
        	表示范围：$[0,2^n-1]$。

    - 十六进制常数：后缀 `h` 或 `H`，且若十六进制常数恰好以字母开头，需要添加 `0` 前缀（如 `0FFFFh` 相当于 C 语言的 `0xFFFF`）。

        二进制常数：后缀 `B`。

- 运算

    - 算术运算：

        - `+`：`add ax,bx` 表示 `ax+=bx`

        - `-`：`sub ax,bx`

        - `*`：`imul`（有符号），`mul`（无符号）
        
			单操作数（`mul`，`imul`）：

              | 数据宽度            | 被乘数（隐含） | 乘数（显式操作）            | 结果                   |
              | ------------------- | -------------- | --------------------------- | ---------------------- |
              | 8 位乘法            | `AL`（8 位）   | 8 位   | `AX`（16 位，`AH:AL`） |
              | 16 位乘法           | `AX`（16 位）  | 16 位 | `DX:AX`（32 位）       |
              | 32 位乘法           | `EAX`（32 位） | 32 位 | `EDX:EAX`（64 位）     |
              | 64 位乘法（x86-64） | `RAX`（64 位） | 64 位 | `RDX:RAX`（128 位）    |

			双操作数（`imul`）：

			`imul ax,bx`

              | 数据宽度        | 被乘数      | 乘数                    | 结果                |
              | --------------- | ----------- | ----------------------- | ------------------- |
              | 16 位           | 16 位寄存器 | 16 位 | 目标寄存器（16 位） |
              | 32 位           | 32 位寄存器 | 32 位 | 目标寄存器（32 位） |
              | 64 位（x86-64） | 64 位寄存器 | 64 位 | 目标寄存器（64 位） |

        - `/`：`idiv`（有符号），`div`（无符号）




            | 数据宽度            | 被除数（隐含）      | 除数（显式操作）            | 商（结果）     | 余数（结果）   |
            | ------------------- | ------------------- | --------------------------- | -------------- | -------------- |
            | 8 位除法            | `AX`（16 位）       | 8 位   | `AL`（8 位）   | `AH`（8 位）   |
            | 16 位除法           | `DX:AX`（32 位）    | 16 位 | `AX`（16 位）  | `DX`（16 位）  |
            | 32 位除法           | `EDX:EAX`（64 位）  | 32 位 | `EAX`（32 位） | `EDX`（32 位） |
            | 64 位除法（x86-64） | `RDX:RAX`（128 位） | 64 位 | `RAX`（64 位） | `RDX`（64 位） |
    
            ??? abstract "示例"
    
                ```asm
                mov dx, -1; 相当于mov dx, 0FFFFh
                mov ax, -6; 相当于mov ax, 0FFFAh
                          ; dx与ax组合起来就是0FFFFFFFAh, 它就是32位的-6  
                mov bx, 2 ; 当除数为16位的寄存器或变量时，被除数一定是=dx（高 16 位）:ax（低 16 位）
                idiv bx   ; ax=商=-3=0FFFDh, dx=余数=0=0000h
                ```
    
    - 关系运算：
    
        - `==`：`je`
        - `!=`：`jne`
        - `>`：有符号数 `jg`，无符号数 `ja`
        - `<`：有符号数 `jl`，无符号数 `jb`
        - `>=`：有符号数 `jge`，无符号数 `jae`
        - `<=`：有符号数 `jle`，无符号数 `jbe`
    
    - 逻辑运算：
    
        - `&&`：用两个嵌套的 if 实现。
        - `||`：用两个并列的 if 实现。
        - `!`
    
    - 位运算：
    
        - `&`：`and al,bl`
        - `|`：`or al,bl`
        - `^`：`xor al,bl`
        - `~`：`not ax`
        - `<<`：`shl al,1`。最后一个被移动的位会被放到 CF 标志中。
        
        	（与 `jc` 配合：若 CF=1，`jc` 会跳转）
        	
        - `>>`：`shr al,1`（无符号），`sar al,1`（有符号）。最后一个被移动的位会被放到 CF 标志中。
        - 循环左移 `rol`，循环右移 `ror`。最后一个被移动的位会在被放到另一端的同时放到 CF 标志中。

### int21h 中断

[常见中断](https://blog.csdn.net/Zach_z/article/details/78576216) `int 21h`：（[中断大全](https://www.uwouni.com/rbrown.htm)）

| AH   | 功能           | 调用参数         | 返回参数    |
| ---- | -------------- | ---------------- | ----------- |
| 00   | 程序终止       | CS=程序段前缀    |             |
| 01   | 键盘输入并回显 |                  | AL=输入字符 |
| 02   | 显示输出       | DL=输出字符（\r → 0Dh，\n → 0Ah）      |             |
| 09   | 显示字符串     | DS:DX=字符串地址 |             |
| 4C   | 带返回码结束   | AL=返回码        |             |

### 分支与循环

用跳转实现。

??? note "do-while"
    ```asm
    code segment
    assume cs:code
    main:
    mov ax,[l1] 
    outer_loop:
        mov bx,[l2]
        middle_loop:
            mov cx,[l3]
            inner_loop:
                ; 循环体操作
                add cx,1
                cmp cx,[r3]
                jle inner_loop     
            add bx,1
            cmp bx,[r2]
            jle middle_loop 
        add ax,1
        cmp ax,[r1]
        jle outer_loop
    code ends
    end main
    ```

### 函数

写在 `main` 前面，用 `call` 调用，用 `ret` 返回

### CPU、内存和端口

- 逻辑地址（段地址 : 偏移地址）
    - 在 8086 中，可以采用逻辑地址间接访问物理地址。物理地址 = 段地址 × 16 + 偏移地址。其中，段地址存储在 16 位段寄存器（如 `cs`、`ds`）中，偏移地址为 16 位值。

    	一个段可以表示的内存为 64KB，且段首地址的物理地址的 16 进制表示的个位必然是 0（段首地址 = 段地址 × 16）。
    
    - 引用变量：段地址只能用段寄存器表示，不能用常数表示。偏移地址可以常数表示。
    
    	- 直接寻址：`段寄存器:[偏移地址（常数）]`
    	- 间接寻址：只有 `bx`、`bp`、`si`、`di` 才可以放在 `[]` 内表示变量的偏移地址。
    	
    		① `段寄存器:[寄存器]`
    		
    		② `段寄存器:[寄存器±常数]`
    		
    		③ `段寄存器:[寄存器+寄存器]`：只能用 `[bx+si],[bx+di],[bp+si],[bp+di]`，不能 `[bx+bp],[si+di]`
    		
    		④ `段寄存器:[寄存器+寄存器±常数]`：不能  `[bx+bp±常数],[si+di±常数]`
    	
    - `seg s` 获取变量 s 所在段的段地址，`offset s` 获取 s 在段内的偏移地址。

- 宽度修饰

    | 宽度修饰词 | 限定变量的宽度 |
    | :--------: | :------------: |
    |  `byte ptr`  |      8 位      |
    |  `word ptr`  |     16 位      |
    | `dword ptr`  |     32 位      |


### 数组

- 数组的定义

    - 字节（byte）类型：db（8 位）

        `char a[100] = {'\0'};` → `a db 100 dup(0)`（dup：duplicate 重复。dup 可嵌套使用）

        `char a[3] = {1, 2, 3};` → `a db 1, 2, 3`
        
        `char a[100];` → `a db 100 dup(?)`（编译时默认 0）
        
        `char a[] = "Hello";` → `a db "Hello", 0`（需手动补 '\0'）
        
        `char a[] = "Hello\0World";` → `a db "Hello", 0, "World", 0`
        
        `char a[] = "Hello\n";` → `a db "Hello", 0Dh, 0Ah, 0` 或 `a db "Hello", 13, 10, 0` 或 `a db "Hello", 15Q, 12Q, 0`（Q 表示八进制数）或 `a db "Hello", 00001101B, 00001010B, 0`

    - 字（word）类型：dw（16 位）

		`short int a[3]={0x1234, 0x5678, 0xABCD};` → `a dw 1234h, 5678h, 0ABCDh`

	- 双字（double word）类型：dd（32 位）
		
		`long int a[3] = {0x100, 0x200, 0x300};` → `a dd 100h, 200h, 300h`

- 数组的引用

    - 地址计算规则

        汇编中指针 q 的 q+i 表示：(unsigned int)q + i（偏移量直接加 i，不乘元素大小）。

        `b dw 1234h, 5678h, 0ABCDh`，定义了 3 个字元素，每个元素占 2 字节。按小端序存储，每个元素的低字节在低地址、高字节在高地址。

        |  值  | 12h  | 34h  | 56h  | 78h  | 0ABh | 0CDh |
        | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
        | 地址 | b+1  |  b   | b+3  | b+2  | b+5  | b+4  |

        `mov ax,b[2]`，b[2] 表示地址 b+2，又 ax 是 16 位寄存器，会访问 b+2（低字节），b+3（高字节），所以 ax 的值是 5678h。同理，`mov ax,b[1]`，ax 的值是 7812h。

    - 段寄存器设置

        `assume cs:code, ds:data`

        `mov ax, data`，`mov ds, ax`

	- 元素访问
	
		一条指令不能同时访问两个变量（如 `add c[0], c[1]` 非法，需先将 `c[1]` 存入寄存器）。

## 显卡内存

- 文本模式下，显卡内存的段地址固定为 0B800h，整个屏幕的显示内容都存储在该段内。

	每个字符占 2 字节：低地址字节存储字符的 ASCII 码（8 位），高地址字节存储字符的颜色属性（8 位，其中低 4 位为前景色，高 4 位为背景色。4 位表示 3 位 RGB 编码和 1 位亮度位）。
	
	25 行 × 80 列，屏幕上的每个位置对应的显存偏移地址计算公式为：偏移地址 = (行号 × 80 + 列号) × 2。
	
	```asm
	code segment
    assume cs:code
    main:
       mov ax, 0B800h; B800h是显卡内存的段地址
       mov ds, ax
       mov byte ptr ds:[0], 'A'; 待输出字符的ASCII码
       mov byte ptr ds:[1], 17h; 待输出字符的颜色
                               ; 高4位是背景色, 低4位是前景色
                               ; 1=蓝色背景, 7=白色前景
                               ; 1=0001      7=0111
                               ;    RGB         RGB

       mov ah, 4Ch
       int 21h
    code ends
    end main
	```

	
	
## int16h  中断

| AH   | 功能         | 输入字符   | 返回参数                   |
| :--- | :----------- | :--------- | :------------------------- |
| 00   | 读取键盘输入 | 可打印字符 | AL=按键的 ASCII 码、AH=按键扫描码 |
|      |              | 上方向键   | AL=00h、AH=48h             |
|      |              | 下方向键   | AL=00h、AH=50h             |
|      |              | 左方向键   | AL=00h、AH=4Bh             |
|      |              | 右方向键   | AL=00h、AH=4Dh             |

## 堆栈

- 堆栈是 “后进先出（LIFO）” 的内存区域，由 ss（段地址）和 sp（栈顶偏移）定位。

- 定义堆栈段：
	
    ```asm
    stk segment stack  ; 必须加stack关键字，标识为堆栈段
    db 100h dup(0)     ; 堆栈大小=100h字节（256字节），无名数组。
	                   ; 此时ss指向stk堆栈段的段基址，sp=堆栈段大小=100h
    stk ends
    ```
    
    若源程序未定义 stack 段，系统会默认，ss = 程序首段的段地址（通常是代码段 cs），sp = 0（栈顶指向段起始位置）。

- 操作

	8086 仅支持 16 位堆栈操作（push/pop=2 字节），80386 + 支持 32 位（push/pop=4 字节）；在 8086 中, push 不能直接压入一个常数，在 80386 中, push 可以压入一个常数。
	
	对于 8086：

	- `push ax` 等价于：sp = sp - 2，ss:[sp] = al，ss:[sp+1] = ah
	
	- `pop ax` 等价于：al = ss:[sp]，ah = ss:[sp+1]，sp = sp + 2 
	
	注意栈顶是低地址，栈底是高地址，从栈底到栈顶，内存地址越来越小。
	
	栈顶元素低字节存 sp、高字节存 sp+1。

- 函数的调用与返回：

	对于近调用/返回（在同一代码段内）
	
    `call f` 等价于：push ip（即 call f 下一条指令的地址，方便跳转回来），然后 jmp f

    `ret` 等价于：pop ip

    （cs:ip 指向 CPU 下一条要执行的地址）

- 堆栈传递函数参数

	C 语言调用约定（__cdecl）：从右往左传参
	
	??? note "获取参数 示例"
	
        ```asm
        code segment
        assume cs:code
        ; 被调函数func内部访问参数：
        func:
            push bp            ; 保存bp
            mov bp, sp         ; 用bp作为基址访问参数
        
            ; 参数位置计算：
            ; bp+0 = 保存的bp值
            ; bp+2 = 返回地址IP
            ; bp+4 = 第一个参数(ax)
            ; bp+6 = 第二个参数(bx)
            ; bp+8 = 第三个参数(cx)
        
            mov ax, [bp+4]     ; 获取第一个参数
            mov bx, [bp+6]     ; 获取第二个参数
            mov cx, [bp+8]     ; 获取第三个参数
        
            pop bp             ; 恢复bp
            ret                ; 返回，参数由调用者清理
        
        main:
            ; 调用者准备参数（从右到左压栈）
            push cx       ; 第三个参数（最右边）
            push bx       ; 第二个参数
            push ax       ; 第一个参数（最左边）
            call func      ; 调用函数
            add sp, 6      ; 调用者清理堆栈（3个参数×2字节=6字节）
        
            mov ah, 4Ch
            int 21h
        code ends
        end main
        ```
  
	??? note "局部变量的使用 示例"
        
        ```asm
        func:
            push bp
            mov bp, sp
            sub sp, 4          ; 为2个局部变量分配空间（每个2字节）
    
            ; bp-4 = 局部变量2
            ; bp-2 = 局部变量1
            ; bp+0 = 保存的bp
            ; bp+2 = 返回地址
            ; bp+4 = 第一个参数
    
            ; 访问局部变量
            mov word ptr [bp-2], 0    ; 初始化局部变量1
            mov word ptr [bp-4], 0    ; 初始化局部变量2
    
            ; 访问参数
            mov ax, [bp+4]
    
            ; ... 函数体 ...
    
            mov sp, bp         ; 清理局部变量（恢复sp到bp）
            pop bp
            ret                ; 返回
	    ```
	    
	??? note "递归 示例"
	