模板：

```asm
.386
code segment use16
assume cs:code
main:

   mov ah, 4Ch
   mov al, 0
   int 21h
code ends
end main
```

### 数据的表示与运算

- 数据的表示

    - 有符号数与无符号数

        - 有符号数：具有符号位，用于表示正数和负数。用补码存储。
        
        	表示范围：$[-2^{n-1},2^{n-1}-1]$，其中非负数范围为 $[0,2^{n-1}-1]$，负数范围为 $[-2^{n-1},-1]$。
			
			??? abstract "补码"
			
                - 补码定义：$x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
    
                    ??? info
    
                        - 原码：最高位为符号位，其余为数值位。
    
                        - 反码：正数反码 = 原码；负数反码 = 原码符号位不变、数值位取反。
    
                            $x_{反码}=\begin{cases}x&(x\geq 0)\\2^n-1-|x|&(x<0)\end{cases}$
    
                        - 补码：正数补码 = 原码；负数补码 = 反码 + 1。
    
                            $x_{补码}=\begin{cases}x&(x\geq 0)\\2^n-|x|&(x<0)\end{cases}$
    
                            性质：设 $a,b>0$，$a_{补码}+(-b)_{补码}=a+(2^n-b)\equiv a-b\pmod {2^n}$。
    
                            因此补码不仅统一了 $+0$ 与 $-0$，也实现了加法与减法的统一。
    
                - 由补码求真值：$x=\begin{cases}x_{补码}&(0\leq x_{补码}<2^{n-1})\\x_{补码}-2^n&(2^{n-1}\leq x_{补码}<2^n)\end{cases}$

        - 无符号数：无符号位，均为数值位。
        
        	表示范围：$[0,2^n-1]$。

    - 十六进制常数：后缀 `h` 或 `H`，且若十六进制常数恰好以字母开头，需要添加 `0` 前缀（如 `0FFFFh` 相当于 C 语言的 `0xFFFF`）。

        二进制常数：后缀 `B`。

- 运算

    - 算术运算：

        - `+`：`add ax,bx` 表示 `ax+=bx`

        - `-`：`sub ax,bx`

        - `*`：`imul ax,bx`（有符号），`mul`（无符号）

        - `/`：`idiv`（有符号），`div`（无符号）


            | 数据宽度            | 被除数    | 商（结果） | 余数（结果） |
            | ------------------- | --------- | ---------- | ------------ |
            | 8 位除法            | `AX`      | `AL`       | `AH`         |
            | 16 位除法           | `DX:AX`   | `AX`       | `DX`         |
            | 32 位除法           | `EDX:EAX` | `EAX`      | `EDX`        |
            | 64 位除法（x86-64） | `RDX:RAX` | `RAX`      | `RDX`        |
    
            ??? abstract "示例"
    
                ```asm
                mov dx, -1; 相当于mov dx, 0FFFFh
                mov ax, -6; 相当于mov ax, 0FFFAh
                          ; dx与ax组合起来就是0FFFFFFFAh, 它就是32位的-6  
                mov bx, 2 ; 当除数为16位的寄存器或变量时，被除数一定是=dx（高 16 位）:ax（低 16 位）
                idiv bx   ; ax=商=-3=0FFFDh, dx=余数=0=0000h
                ```
    
    - 关系运算：
    
        - `==`：`je`
        - `!=`：`jne`
        - `>`：有符号数 `jg`，无符号数 `ja`
        - `<`：有符号数 `jl`，无符号数 `jb`
        - `>=`：有符号数 `jge`，无符号数 `jae`
        - `<=`：有符号数 `jle`，无符号数 `jbe`
    
    - 逻辑运算：
    
        - `&&`：用两个嵌套的 if 实现。
        - `||`：用两个并列的 if 实现。
        - `!`
    
    - 位运算：
    
        - `&`：`and al,bl`
        - `|`：`or al,bl`
        - `^`：`xor al,bl`
        - `~`：`not ax`
        - `<<`：`shl al,1`。最后一个被移动的位会被放到 CF 标志中。
        
        	（与 `jc` 配合：若 CF=1，`jc` 会跳转）
        	
        - `>>`：`shr al,1`（无符号），`sar al,1`（有符号）。最后一个被移动的位会被放到 CF 标志中。
        - 循环左移 `rol`，循环右移 `ror`。最后一个被移动的位会在被放到另一端的同时放到 CF 标志中。

### int21 中断

[常见中断](https://blog.csdn.net/Zach_z/article/details/78576216) `int 21h`：（[中断大全](https://www.uwouni.com/rbrown.htm)）

| AH   | 功能           | 调用参数         | 返回参数    |
| ---- | -------------- | ---------------- | ----------- |
| 00   | 程序终止       | CS=程序段前缀    |             |
| 01   | 键盘输入并回显 |                  | AL=输入字符 |
| 02   | 显示输出       | DL=输出字符（\r → 0Dh，\n → 0Ah）      |             |
| 09   | 显示字符串     | DS:DX=字符串地址 |             |
| 4C   | 带返回码结束   | AL=返回码        |             |

### 堆栈

`push ax`：堆栈指针 -=2，再把 ax 存放到新指针指向的内存中

`pop cx`：把当前堆栈指针指向的内容取出保存到 cx，再堆栈指针 +=2

### 分支与循环

用跳转实现。

??? note "do-while"
    ```asm
    code segment
    assume cs:code
    main:
    mov ax,[l1] 
    outer_loop:
        mov bx,[l2]
        middle_loop:
            mov cx,[l3]
            inner_loop:
                ; 循环体操作
                add cx,1
                cmp cx,[r3]
                jle inner_loop     
            add bx,1
            cmp bx,[r2]
            jle middle_loop 
        add ax,1
        cmp ax,[r1]
        jle outer_loop
    code ends
    end main
    ```

### 函数

写在 `main` 前面，用 `call` 调用，用 `ret` 返回