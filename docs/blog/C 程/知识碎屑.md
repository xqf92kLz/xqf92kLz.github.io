### 整数

- 非符号数（unsigned number）

	8 位非符号数的二进制取值范围是 [0000 0000, 1111 1111]，十六进制范围是 [0x00, 0xFF]（其中 0x 是 C 语言中十六进制常数的前缀），十进制范围是 [0,255]
	
	16 位非符号数的二进制取值范围是 [16 个 0, 16 个 1]，十六进制范围是 [0x0000, 0xFFFF]，十进制范围是 [0,65535]
	
	32 位非符号数的二进制取值范围是 [32 个 0, 32 个 1]，十六进制范围是 [0x00000000, 0xFFFFFFFF]，十进制范围是 [0, 4294967295 = 2 的 32 次方 -1]
	
- 符号数（signed number）

	在计算机中用补码来表示符号数
	
	8 位符号数的二进制范围是 [1000 0000, 0111 1111]，十六进制范围是 [0x80, 0x7F]，十进制范围是 [-128, +127]。其中正数范围是 [0000 0000, 0111 1111] 即 [0,+127]，负数范围为 [1000 0000, 1111 1111] 即 [-128,-1]。
	
	其中明显的特征是，正数的二进制最高位 = 0，负数的二进制的最高位 = 1。
	
	8 位整数的二进制补码的最高位恒为 0，其余 7 位表示概述的值。

### 实数数据的存储

规格化数的形式是为 1.M × 2^e，但 E 有下限，所以还会有非规格化数 0.M  × 2^e。

IEEE 754 标准的浮点数：符号位（S） + 指数位（E，= 实际指数 e + 偏移量） + 尾数位（M，不含小数点前的 1）。

科学计数法的小数部分（不含小数点前的 1）。

- 单精度（32 位）：1 位符号位 + 8 位指数位（范围 0~255。偏移量为 127，实际指数范围为 -126 ~ +127） + 23 位尾数位（实际有效数字是 1.M，共 24 位：1 位隐含的 1 + 23 位存储的 M）
- 双精度（64 位）：1 位符号位 + 11 位指数位（范围 0~2047。偏移量为 1023，实际指数范围为 -1022 ~ +1023） + 52 位尾数位（实际有效数字是 1.M，共 53 位：1 位隐含的 1 + 52 位存储的 M）

### 转义字符

`\n`，`\t`，`\\`，`\"`，`\'`

`\ddd` 1~3 位八进制整数所代表的字符（如 `\102` 表示 ASCII 码是八进制数 102 的字符）

`\xhh` 1~2 位十六进制整数所代表的字符（如 `\x41` 表示 ASCII 码是十六进制数 41 的字符）

### 输入输出

整型：

- 十进制：int `%d`，long `%ld`，unsigned `%u`，unsigned long `%lu`

    八进制：`%o`，`%lo`，`%o`，`%lo`

    十六进制：`%x`，`%lx`，`%x`，`%lx`

    指定输出宽度为 m（若实际位数 <m，左端补空格；若实际位数 ≥ m，按实际位数）：`%md`

实型：

- 小数形式：float `%f`，double `%lf`

    指数形式：`%e`，`%le`

    指定输出宽度为 m（左端补空格）、保留 n 位小数：`%m.nf`

### 类型转换

非赋值运算的类型转换

<img src="https://cdn.luogu.com.cn/upload/image_hosting/vdq6hikh.png" style="zoom:33%;" />

短 → 长，**有符号 → 无符号**

### 运算符

![img](https://img.memset0.cn/2024/02/08/eu54EX0G.png)

![img](https://img.memset0.cn/2024/02/08/kpoaJNvm.png)

![img](https://img.memset0.cn/2024/02/08/P8WtKyi5.png)

### typedef

```cpp
typedef unsigned long int dword;
dword a;	//相当于 unsigned long int a;

typedef int tenint[10];
tenint x;	//相当于 int x[10]; 即直接用 x 替换掉 int tenint[10]; 中的 tenint

typedef int tenint[10];
tenint x[2];	//相当于 int x[2][10];

typedef char (*ap)[10];
ap p;	//相当于 char (*p)[10]; 即直接用 p 替换掉 char (*ap)[10] 中的 ap

typedef struct st{
    char *name;
    int score;
}ST;
ST a,*p;
```

### malloc 与 free

malloc：memory allocation

`malloc()` 内存分配函数的原型：

```cpp
void * malloc(int n);
//n 是需要分配的内存块的以字节为单位的长度。
//malloc() 返回内存块的首地址
```

头文件要包含 `alloc.h` 或 `stdlib.h`。

`char *p; p=malloc(100);gets(p);`  相当于 `char a[100]; gets(a);`

`free(p);` 释放这块内存。

### 变量

变量的存储类别：局部动态变量，局部静态变量，全局静态变量，全局变量

作用域：指变量的有效范围，即变量可以在该区域内被引用

生命期：指变量从诞生到死亡的周期

1. 局部动态变量（local automatic variable）

	① 定义在函数体内或函数头中（即形参）
	
	② 用 auto 修饰，不过 auto 可以省略。比如 `int f(auto int n)` 可以写成 `int f(int n)`
	
	③ 作用域（scope）及生命期（life time/duration）均为定义该变量的语句所在的代码块，即用 {} 括起来的复合语句

2. 局部静态（local static）变量

	① 定义在函数体内
	
	```cpp
	int f(int n){
		static int i=1;
		i++;
		return i+n;
	}
	```
	
	② 局部变量的定义语句早在 main() 运行时就已经执行过，并且该变量也在那时诞生，故每次该变量所在的函数被调用时，定义该变量的语句并不被执行
	
	③ 局部静态变量并不会因为所在函数的调用结束而死亡（生命周期贯穿整个程序执行过程，但作用域仅局限于定义它的局部范围）
	
	④ 局部静态变量在定义时若没有初始值，则它的值一定等于 0

3. 全局静态变量

	全局静态变量只能在本文件内引用，不能跨文件。

4. 全局变量（global variable）

	全局变量可以跨文件引用。
		
	`extern int n` 声明这个变量 n 在其他文件（注意不是定义，定义在其他文件中 `int n`），即不在当前文件中。

### 神秘知识点

- `(l<x<r)` 可以过编译，等价于 `((l<x)<r)`。如 `(2<x<5)` 的值一定是 True，`(-4<x<-2)` 的值一定是 False。

- 逗号表达式 `(表达式 1,表达式 2,...,表达式 n)`，从左到右依次执行，最后返回 `表达式 n`。

- 自增自减的对象只能是变量，不能是常量或表达式。
- `a[i]` 本质是 `*(a+i)`，所以 `char *p=&a[-1]` 可以过编译，`p` 指向 `a[0]` 前一个内存单位。
- C 语言 `math.h` 只有 `int abs(int x);` 没有 `double abs(double x);`，所以 `abs(-3.14)` 的结果是 3 而非 3.14。

