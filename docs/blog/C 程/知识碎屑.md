### 整数

- 非符号数（unsigned number）

	8 位非符号数的二进制取值范围是 [0000 0000, 1111 1111]，十六进制范围是 [0x00, 0xFF]（其中 0x 是 C 语言中十六进制常数的前缀），十进制范围是 [0,255]
	
	16 位非符号数的二进制取值范围是 [16 个 0, 16 个 1]，十六进制范围是 [0x0000, 0xFFFF]，十进制范围是 [0,65535]
	
	32 位非符号数的二进制取值范围是 [32 个 0, 32 个 1]，十六进制范围是 [0x00000000, 0xFFFFFFFF]，十进制范围是 [0, 4294967295 = 2 的 32 次方 -1]
	
- 符号数（signed number）

	在计算机中用补码来表示符号数
	
	8 位符号数的二进制范围是 [1000 0000, 0111 1111]，十六进制范围是 [0x80, 0x7F]，十进制范围是 [-128, +127]。其中正数范围是 [0000 0000, 0111 1111] 即 [0,+127]，负数范围为 [1000 0000, 1111 1111] 即 [-128,-1]。
	
	其中明显的特征是，正数的二进制最高位 = 0，负数的二进制的最高位 = 1。
	
	8 位整数的二进制补码的最高位恒为 0，其余 7 位表示概述的值。
	
	8 位 -1 的二进制补码怎么求？先求出 8 位 +1 的二进制补码 = 0000 0001，再求 +1 的相反数 = 1111 1111。8 位 + 8 位 = 8 位，高于 8 位的丢弃，那么 0000 0001 + 1111 1111 = (1) 0000 0000 = 0。
	
	+2 = 0000 0010，则 -2 = 1111 1110
	
	+127 = 0111 1111，则 -127 = 1000 0001
	
	-128 = 1000 0000。+127 = 01111 1111，+1 = 0000 0001，1000 0000 + 01111 1111 + 0000 0001 = 0
	
	-128 - 1 = 1000 0000 - 0000 0001 = 0111 1111 = +127 发生了溢出（overflow）
	
	127 + 1 = 0111 1111 + 0000 0001 = 1000 0000 = -128 也发生了溢出

### 变量

- 变量定义：变量由大写字母、小写字母、数字、下划线组成，且不能用数字开头。

- 变量类型：

    %d 表示有符号十进制，%u 表示无符号十进制，%o 表示八进制，%x 表示十六进制（字母小写），%X 表示十六进制（字母大写）。

    short int %hd，h 取自 short 的第二个字母（不取 short 的第一个字母是因为 %s 对应字符串），或者理解为 half。

    | 变量类型                  | 位数（位） | 取值范围                                 | 输入 / 输出格式     |
    | ------------------------- | ---------- | ---------------------------------------- | ------------------- |
    | `char`                    | 8          | [-128, 127]（-2⁷, 2⁷-1）                 | `%c`、`%d`          |
    | `unsigned char`           | 8          | [0, 255]（0, 2⁸-1）                      | `%u`、`%c`          |
    | `short int`               | 16         | [-32768, 32767]（-2¹⁵, 2¹⁵-1）           | `%hd`、`%hx`、`%ho` |
    | `unsigned short`          | 16         | [0, 65535]（0, 2¹⁶-1）                   | `%hu`、`%hx`、`%ho` |
    | `int`（VC 环境）          | 32         | [-2147483648, 2147483647]（-2³¹, 2³¹-1） | `%d`、`%x`、`%o`    |
    | `unsigned int`（VC 环境） | 32         | [0, 4294967295]（0, 2³²-1）              | `%u`、`%x`、`%o`    |
    | `long int`                | 32         | [-2147483648, 2147483647]（-2³¹, 2³¹-1） | `%ld`、`%lx`、`%lo` |
    | `unsigned long int`       | 32         | [0, 4294967295]（0, 2³²-1）              | `%lu`、`%lx`、`%lo` |
    | `float`                   | 32         | 约 ±3.4×10³⁸（浮点近似值）               | `%f`、`%e`          |
    | `double`                  | 64         | 约 ±1.7×10³⁰⁸（浮点近似值）              | `%lf`、`%le`        |
    | `long double`             | 80         | 约 ±1.2×10⁴⁹³²（浮点近似值）             | `%Lf`               |

    上述有些类型可以简化，例如 `short int` → `short`，`long int` → `long`，`unsigned short int` → `unsigned short`。
    
    double 类型输出时的格式控制符可以用 %lf 也可以用 %f，但输入时必须用 %lf。
    
- 变量的存储类别：局部动态变量，局部静态变量，全局静态变量，全局变量

    作用域：指变量的有效范围，即变量可以在该区域内被引用

    生命期：指变量从诞生到死亡的周期

    1. 局部动态变量（local automatic variable）

        ① 定义在函数体内或函数头中（即形参）

        ② 用 auto 修饰，不过 auto 可以省略。比如 `int f(auto int n)` 可以写成 `int f(int n)`

        ③ 作用域（scope）及生命期（life time/duration）均为定义该变量的语句所在的代码块，即用 {} 括起来的复合语句

    2. 局部静态（local static）变量

        ① 定义在函数体内

        ```cpp
        int f(int n){
			static int i=1;
			i++;
			return i+n;
        }
        ```

        ② 局部变量的定义语句早在 main() 运行时就已经执行过，并且该变量也在那时诞生，故每次该变量所在的函数被调用时，定义该变量的语句并不被执行

        ③ 局部静态变量并不会因为所在函数的调用结束而死亡（生命周期贯穿整个程序执行过程，但作用域仅局限于定义它的局部范围）

        ④ 局部静态变量在定义时若没有初始值，则它的值一定等于 0

    3. 全局静态变量

        全局静态变量只能在本文件内引用，不能跨文件。

    4. 全局变量（global variable）

        全局变量可以跨文件引用。

        `extern int n` 声明这个变量 n 在其他文件（注意不是定义，定义在其他文件中 `int n`），即不在当前文件中。

### 常数

- char 类型的常数格式

    ① `'A'`

    ② `'\n'`，`'\t'`，`'\r'` 回车，`'\b'` 光标前移，`'\a'` 喇叭发声，`'\''`，`'\\'`，`'\"'`，`'"'`

    `'''` 语法错误，`'\''` 语法正确；`'\'` 语法错误，`'\\'` 语法正确；`'"'` 语法正确，`"'"` 语法正确，`"""` 语法错误，`"\""` 语法正确。

    ③ `'\x0A'` 十六进制字符常数，\x 后面跟 1~2 位十六进制数，\x 是十六进制字符常数的前缀。`'\x0A'` 等价于 `'\n'`

    ④ `'\12'`，`'\101'` 八进制字符常数，\ 后面跟 1~3 位把进制数。`'\12'` 等价于 `'\0A'` 等价于 `'\n'`，`'\101'` 等价于 `'A'`

    ASCII 码小于 32 及大于 127 的符号通常无法通过键盘输入，所以要使用 ②、③、④ 的形式表示。例如要表示 ASCII 码等于 0 的那个字符可以用 `'\0'`（④ 的形式）。

    C 语言中把 `'\0'` 用作字符串的结束标记，例如 `"ABC"` 中包含的元素一共有以下 4 个：`'A'`、`'B'`、`'C'`、`'\0'`。

- int 类型的常数格式

    `int a=100;`

    `int a=0x64;`，0x 是十六进制（hexadecimal）整型常数的前缀

    `int a=0101;` 相当于 `int a=65;`，0 是八进制（octal）整型常数的前缀

    `123` 类型是 int

    `254U` 相当于 `(unsigned int)254`

    `0L` 相当于 `(long int)0`

    `123UL` 相当于 `(unsigned long int)123`

    `0x1AUL` 相当于 `(unsigned long int)0x1A` 即 `26UL`

- 小数类型的常数格式

    `3.14`，`3.14E-2` 表示 3.14×10⁻²，类型均为 double

    注意 E 的后面必须是整数，不能是小数，如 `3.14E0.2` 语法错误。

    `3.14F` 相当于 `(float)3.14`，后缀 F 表示此数的类型为 float。不加 F 后缀则默认类型为 double。

### 字符与字符串

- 字符

    - 在 C 语言中，字符与它的 ASCII 码是等价的。字符本质上是一个 8 位数。

        `'A'` = 0x41 = 65

        `'a'` = 0x61 = 97

        `' '` = 0x20 = 32

        `'0'` = 0x30 = 48

    - 大小写字母的相互转化

        大写字母 + 32 = 小写字母

        大写字母 + 0x20 = 小写字母

        大写字母 + `' '` = 小写字母

- 字符与字符串区别

	`"A"` 与 `'A'` 的区别：`"A"` 由 `'A'` 及 `'\0'` 两个元素构成
	
	`""` 称为空串（null string），它里面有一个元素，即 `'\0'`
	
	`''` 语法错误
	
	凡是用双引号引起来的字符串，其最后一个隐藏的元素一定是 `'\0'`，它起到终结该字符串的作用
	
- 字符串

    `strlen(s)`：返回 `'\0'` 左边的元素个数，在头文件 string.h 中

    `gets(a)`：输入一个字符串，以回车结束。gets 也会像 scanf() 的 %s 格式那样自动在字符串末尾填入 `'\0'`

### 各种类型的混合计算

- 数据类型的自动转化

    ① 宽度小的类型服从宽度大的类型

    ② 有符号要服从非符号，如 char 要服从 unsigned char
    
    ③ 整数服从小数，如 long 要服从 float
    
    ④ char 类型无论跟谁运算都要升级成 int 类型

- 小类型整数转化成大类型整数时的扩充问题

    ① 非符号数的 0 的扩充（被扩充的数是非符号数），高位扩充 0

    ② 符号数的符号扩充（被扩充的数是符号数），负数高位扩充 1，非负数扩充 0

    （类似知识点：负数右移时左边要补 1，正数右移时左边要补 0）

### 运算符和表达式

- 优先级（precedence）与结合性（association）

    | Operator                                                     | Order of evaluation |
    | :----------------------------------------------------------- | :------------------ |
    | `()`、`[]`、`.`、`->`、`++`（变量++）、`--`（变量--）        | left to right       |
    | `!`、`~`、`++`（++变量）、`--`（--变量）、`&`（取地址）、`*`（解引用）、`(type)`、`sizeof` | **right to left**   |
    | `*`、`/`、`%`                                                | left to right       |
    | `+`、`-`                                                     | left to right       |
    | `<<`、`>>`                                                   | left to right       |
    | `<`、`<=`、`>`、`>=`                                         | left to right       |
    | `==`、`!=`                                                   | left to right       |
    | `&`                                                          | left to right       |
    | `^`                                                          | left to right       |
    | `|`                                                          | left to right       |
    | `&&`                                                         | left to right       |
    | `||`                                                         | left to right       |
    | `?:`                                                         | **right to left**   |
    | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`^=`、`|=`、`>>=`、`<<=` | **right to left**   |
    | `,`                                                          | left to right       |

- 逗号运算符和逗号表达式：

    逗号表达式的值等于最后一个表达式的值。
    
- 长度测试运算符：

    sizeof(类型名或表达式)
    
- 条件运算符：

    右结合，`a>0?1:a<0?-1:0` 相当于 `a>0?1:(a<0?-1:0)`

### 数组

- `int a[n];` 在 C89 中是语法错误，因为定义数组时，元素个数必须为常数，不能是变量。在 C99 及 C++ 中允许这样写。

    `int a[];` 语法错误，因为必须列出各个元素的值。

- 数组元素个数 `n=sizeof(a)/sizeof(a[0])`，其中 `sizeof(a)` 表示 a 数组中全体元素的总宽度

- 在内存中，数组的各个元素是连续存放的。

    注意下标可以故意越界。对于 `short int a[3][4];`，`a[0][4]` = `a[1][0]`，`a[1][-1]` = `a[0][3]`

- `int a[][]={{1,2,3},{4,5,6}};` 编译错误，`int a[][3]={{1,2,3},{4,5,6}};` 或 `int a[2][3]={{1,2,3},{4,5,6}};` 编译正确。

    `int f(int a[][])` 编译错误，`int f(int a[][3])` 或 `int f(int a[2][3])` 编译正确。

    多维数组只有第一个维度的大小可以省略。

### 实数数据的存储

规格化数的形式是为 1.M × 2^e，但 E 有下限，所以还会有非规格化数 0.M  × 2^e。

IEEE 754 标准的浮点数：符号位（S） + 指数位（E，= 实际指数 e + 偏移量） + 尾数位（M，不含小数点前的 1）。

科学计数法的小数部分（不含小数点前的 1）。

- 单精度（32 位）：1 位符号位 + 8 位指数位（范围 0~255。偏移量为 127，实际指数范围为 -126 ~ +127） + 23 位尾数位（实际有效数字是 1.M，共 24 位：1 位隐含的 1 + 23 位存储的 M）
- 双精度（64 位）：1 位符号位 + 11 位指数位（范围 0~2047。偏移量为 1023，实际指数范围为 -1022 ~ +1023） + 52 位尾数位（实际有效数字是 1.M，共 53 位：1 位隐含的 1 + 52 位存储的 M）

### #define

- 定义符号常数：`#define PI 3.14`

- 定义宏（macro）

	注意宏展开：
	
	`#define F(x,y) x+y`，`z=F(a,b)*c` → `z=a+b*c`
	
	`#define F(x,y) (x*y)`，`z=F(a+b,c+d)*c` → `z=(a+b*c+d)*c`
	
	`#define F(x,y) ((x)*(y))`，`z=F(a+b,c+d)*c` → `z=((a+b)*(c+d))*c`

### typedef

```cpp
typedef unsigned long int dword;
dword a;	//相当于 unsigned long int a;

typedef int tenint[10];
tenint x;	//相当于 int x[10]; 即直接用 x 替换掉 int tenint[10]; 中的 tenint

typedef int tenint[10];
tenint x[2];	//相当于 int x[2][10];

typedef char (*ap)[10];
ap p;	//相当于 char (*p)[10]; 即直接用 p 替换掉 char (*ap)[10] 中的 ap

typedef struct st{
    char *name;
    int score;
}ST;
ST a,*p;
```

### 神秘知识点

- C 语言 `math.h` 只有 `int abs(int x);` 没有 `double abs(double x);`，所以 `abs(-3.14)` 的结果是 3 而非 3.14。

