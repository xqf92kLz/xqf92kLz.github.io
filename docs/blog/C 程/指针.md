### 定义

- 变量（variable）一定同时具备两个属性：① 地址；② 值。

    变量的值可以改变，地址不能改变。

    变量的值占用内存空间，地址不占内存空间。

    变量的地址指向（point to）该变量，变量的地址就是变量的指针（pointer）。

- 小端规则：当宽度 >1 字节的变量存入内存时，先存低位字节，后存高位字节。

- `char *p` 定义一个指针变量 p，它指向一个 char。p 的类型是 char *，p 指向的对象的类型是 char（p 只能被赋值为某个 char 类型的变量的地址）。

    可以把 * 理解为“←”，`char *p` 表示 p 指向 char，`*p` 表示 p 指向的对象（`a=*p` 表示 p 指向 a）。

    定义多个指针变量：`long int *p,*q` 是对的，`long int *p,q` 是错的。

### 基础操作

- `p=&a` 表示 p 指向 a，`*p` 表示 p 指向的对象。

- `%p` 格式用于输入或输出一个地址或指针。

- 合法的指针运算：① p+i 指针加减一个整数；② q-p 指针减法；③ q>p 指针比较指针

    `p++` 表示让 p 指向下一个同类型的对象。所以 `p++` 前后 p 的值相差的可能不是 1，这取决于类型的宽度。

    p+1=(int)p+1*sizeof(\*p)

    只有 q、p 同类型时，才可以做减法运算。q-p 表示这两个变量所指向的对象之间相差的元素个数。

    q-p=((int)q-(int)p)/sizeof(*p)

- 指针的宽度：所有指针类型的宽度都是一致的，sizeof(指针类型) 取决于地址的最大值。在 TC 中，答案是 2；在 VC6 及 Devcpp 中，答案是 4；在 pta 系统的 gcc 中以及 64 位 VC 中，答案是 8。

- 指针的赋值：同类型的指针变量可以相互赋值。

	当把某个与 p 类型不同的指针赋值给 p 时，必须做强制类型转化。

### 特殊指针

- 三个指针相关的概念

	1. 野指针（wild pointer）
	
		比如 `char *p`，未进行赋值，p 是个随机值，不能引用 \*p。

		如何防止野指针：一定要在引用 \*p 前先对 p 本身赋值
	
	2. 空指针（NULL pointer）
		
		当 p=NULL，即 p=0 时，我们称 p 是一个空指针，所以空指针就是 0 地址。
		
		C 语言规定，0 地址对应的内存单元不存放任何合法的对象。
		
		所有整数中，只有 0 可以直接赋值给指针变量，不需要做强制类型转化。
		
		当 p=0 时，任何时候都不能引用 \*p（段错误）。
	
	3. 通用指针（general pointer）

		void 不能用来定义第一个变量，因为它的含义是无类型。`void a;` 此时 a 的宽度未知，肯定会导致语法错误。
		
		- void 可以用来表示返回值的类型，此时表示该函数无返回值。
		- 同时 void 也可以用来表示形参，此时表示该函数没有参数。
		- `void *p;` 此时 p 就是通用指针，其中 void * 就是通用指针类型。
		
			p 是万能指针容器，它可以接受任何类型指针的赋值。p 也是万能赋值者，它可以赋值给任何类型的指针变量。
			
			当 p 的类型是 void * 时，任何时候都不能引用 \*p（语法错误）。

### 数组与指针

- 一维数组名（在非 sizeof、非 &、非数组初始化场景下）等价于该数组首元素的地址。定义 `int f(int a[])` 实际上是 `int f(int *a)`，调用 `f(a)`实际上是 `f(&a[0])` 。
	
	当 p 是一个指针变量时，`p[i]` 表示 p 所指向的第 i 个元素，其中 p[0] 是 p 当前指向的对象。

	p[i] == \*(p+i)

- 数组指针

	`int (*p)[4];` p 是数组指针，它指向了一个由 4 个 int 构成的一维数组。（看成 `int X[4];`，那么 \*p=X，所以 p 指向一维数组 X）
	
	`p=&a[0]`，则 a[i][j] 可以用 p 来引用：`*(*(p+i)+j)`，`*(p[i]+j)`，`(*(p+i))[j]`，`p[i][j]`
	
	定义 `int f(int a[3][4])` 实际上是 `int f(int (*a)[4])`，此时 `a[i][j]` 即 `*(*(a+i)+j)`；`int a[3][4]` 再调用 `f(a)`实际上是 `f(&a[0])`。
	
	注意 `int *r[3]`，r 是指针数组，即指针构成的数组。`int (*p)[4]`，p 是指针变量，是数组指针。

- 二维数组的名字等价于该数组首行的地址，即 `a` 等价于 `&a[0]`。\*\*a=\*a[0]=a\[0][0]

	```cpp
    int a[3][4];
    /*
    函数调用时传参：
    a 等价于 &a[0]，类型为数组指针 int (*)[4]，指向 a[0]
    *a 等价于 a[0]，类型为 int*，指向 a[0][0]
    **a 等价于 a[0][0]，类型为 int
    函数形参：
    int **a 类型为 int**
    int a[] 类型为 int*
    int a[][4] 类型为 int (*)[4]
    int (*a)[4] 类型为 int (*)[4]
    */
    void f(int **a);       // CE
    void f(int a[]);       // CE
    void f(int a[][]);     // CE
    void f(int a[3][]);    // CE
    void f(int a[3][4]);   // √
    void f(int a[][4]);	   // √
    void f(int (*a)[4]);   // √
	```

- 数组与指针的辨析

	`char a[100]="ABC"; char *p=a;`（或 `char *p=&a[0];`）
	
	- 相同点：
	
        p[i]==a[i]
        
        \*(p+i)==\*(a+i)
	
	- 不同点：
	
		sizeof(a)=100 与 sizeof(p)=4 不相同，此处的 a 不能替换成 &a[0]
		
		`a="XYZ";` 与 `p="XYZ";` 不相同，前者会语法错误，后者不会。a 等价于 &a[0] 是常数、非变量
		
		&a 与 &p 类型不同，&a 的类型是 char (\*t)[100] 的类型，&p 的类型是 char \*\*。 此处的不能把 &a 理解成 &&a[0]，因为地址不是对象（对象是有内存空间的，有内存空间的才可以取地址），地址不能再取地址。

### 指针的指针

- `int **t`，t 是指针的指针（二级指针）。

	`int **t,*s; s=&a[0],t=&s;` t 指向指针 s（t 的值为指针 s 的地址），s 指向 a[0]（s 的值为 a[0] 的地址，同时 s 自己有个地址）。\*t=s，\*\*t=\*s=a[0]

### 指针与字符串

- `char a[100]="ABC"; puts(a);` 等价于 `puts(&a[0])`。
	
	`char a[100]; a="ABC"` 语法错误，因为 `a` 即 `&a[0]` 是常数。`char a[100]="ABC"` 正确。`char a[100]; strcpy(a,"ABC");` 正确。
	
	???+ warning
		注意 `*` 的优先级高于 `+`。`putchar(*a+3)` 输出 D。

	`char *p="XYZ"; puts(p);`，`"XYZ"` 等价于 `&"XYZ"[0]`，先存放 XYZ，再赋值指针变量 p。`puts(p)` 即 `puts(&"XYZ"[0])`。
	
	`puts("Hello")` 等价于 `puts(&"Hello"[0])`。

### 结构指针

- 关键词 struct 与标签名构成了结构类型名。标签名可以省略。

    `struct st a,b`，a、b 是结构类型的变量。注意这里与 C++ 有区别！C 语言中定义结构变量时必须要写 struct。

- `struct st *p`，p 是结构指针变量。

	???+ warning
		注意 `.` 的优先级高于 `*`。`struct st a[3],*p; p=&a[0]`，`*(p+i).name` 错误，`(*(p+i)).name` 正确，`(p+i)->name` 正确。
	
	`p->` 表示 p 所指向对象的 ...。`(p+i)->` 等价于 `(*(p+i)).`。`->` 左边必须是指针，`.` 左边必须是对象。


### 指针与函数

- 函数指针（指向函数的指针）

	`int (*p)(int,int);` 定义了一个函数指针 p 指向一个参数类型表为 int,int 的函数。
	
	`int f(int x,int y);`，`p=fun`，将 p 指向函数 f()。
	
	`f(x,y)` 或 `(*p)(x,y)` 调用函数。
	
	`int calc(int (*p)(int,int));` 可以让函数指针 p 作为函数的参数。
	
	C 语言中，函数的机器指令存储在程序的 “代码段”，函数名本质上是这个代码段起始位置的地址（类似数组名是数组首地址）。函数名是 “常量指针”，不能被修改。

- 指针作为函数返回值

	不能再实现函数时返回在函数内部定义的自动变量的地址，因为所有的自动变量在函数返回时就会消亡，其值不再有效
	
	
	能返回：主调函数中变量的地址、静态存储区中变量的地址、函数中通过动态内存分配方式建立的内存单元的地址

	不能返回：函数内部定义的自动变量的地址

### malloc 与 free

malloc：memory allocation

`malloc()` 内存分配函数的原型：

```cpp
void * malloc(int n);
//n 是需要分配的内存块的以字节为单位的长度。
//malloc() 返回内存块的首地址
```

头文件要包含 `alloc.h` 或 `stdlib.h`。

`char *p; p=malloc(100);gets(p);`  相当于 `char a[100]; gets(a);`

`free(p);` 释放这块内存。

### 链表

链表是一种动态存储分配的数据结构

```cpp
struct st{
	char name[10];
	int score;
	struct st *next;
};
int main(){
	struct st *p,*q;
	p=(struct st*)malloc(sizeof(struct st));
	scanf("%s%d",p->name,&p->score);
	q=(struct st*)malloc(sizeof(struct st));
	scanf("%s%d",q->name,&q->score);
	p->next=q,q->next=NULL;
}
```

删除节点：

```cpp
if(pfore==NULL) phead=p->next,free(p);
else pfore->next=p->next,free(p);
```

### 命令行参数

- `int main(int argc,char *argv[])`

	argc：命令行参数（包括命令）的个数
	
	argv：以字符串敞亮形式存放的命令行参数（包括命令本身）
	
	如命令行 `test world`，argc 为 2，argv 的两个元素分别指向 test 和 world。