??? info "查漏补缺"

    - 常量
    
        - 若整数常量第一个数字是 0，那么该常量被看做八进制数
    
        - 字符串常量末尾有 '\0'
    
            若用字符串常量初始化字符数组，会自动添 '\0'
    
        - switch 语句，`case 常量表达式:` 的常量表达式的类型必须是整型，且任意两个 case 语句中的常量表达式值不应该相等
    
    - 运算符
    
        | Operator                                                     | Order of evaluation |
        | :----------------------------------------------------------- | :------------------ |
        | `()`、`[]`、`.`、`->`、`++`（变量++）、`--`（变量--）        | left to right       |
        | `!`、`~`、`++`（++变量）、`--`（--变量）、`&`（取地址）、`*`（解引用）、`(type)`、`sizeof` | **right to left**   |
        | `*`、`/`、`%`                                                | left to right       |
        | `+`、`-`                                                     | left to right       |
        | `<<`、`>>`                                                   | left to right       |
        | `<`、`<=`、`>`、`>=`                                         | left to right       |
        | `==`、`!=`                                                   | left to right       |
        | `&`                                                          | left to right       |
        | `^`                                                          | left to right       |
        | `|`                                                          | left to right       |
        | `&&`                                                         | left to right       |
        | `||`                                                         | left to right       |
        | `?:`                                                         | **right to left**   |
        | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`^=`、`|=`、`>>=`、`<<=` | **right to left**   |
        | `,`                                                          | left to right       |
    
        初等运算符 > 单目运算（从右往左）> 算术运算 > 移位运算 > 关系运算 > 位逻辑运算 > 逻辑运算 > 三目运算（从右往左）> 赋值运算（从右往左） > 逗号运算
    
    - 表达式
    
        C89 标准下，如果除法的两个操作数中有一个是负数，那么取整的方向是不确定的
    
    - 指针
    
        `struct point *pt;`：声明了一个指向 point 结构类型的指针 pt。指向数组的指针被声明为指向该数组所容纳元素的指针，这里声明的 pt 也可以指向一个数组。
    
        `char *pt[100];`：声明了一个包含有 100 个字符指针元素的数组
    
        `struct point(*fnPrt)(int);` 声明了一个指向返回值类型为 struct point 的函数的指针，该函数接受一个整型参数
    
        `void*` 是通用的指针类型，C 语言保证任何类型的指针都可以保存到 `void*` 类型中，并且随后将其从 `void*` 类型的指针中取出而不改变原来的值。除了这个特例外，C 语言不允许不同类型指针之间的转换
    
    - 结构变量
    
        `struct 结构名 变量列表;` 声明结构变量
    
    - 存储类型
    
        C 语言一共有 4 种存储类型：auto、static、extern 和 register
    
        当为函数指定存储类型的时候，只能用关键字 static 或 extern。若不指定，默认为 extern
    
        将变量指定为 extern 时，变量必须在某处声明时不使用 extern 关键字，或者某处使用 extern 但进行了初始化
    
        将变量指定为 register 时，不一定确保放在寄存器中；根据实现不同，对于能够声明的变量类型有各种限制；不能取该类型变量的地址
    
    - 函数
    
        函数的参数传递按照值引用的方式进行，即在函数内部不能修改实际的参数。如果给函数传递一个指针参数，函数内部可以对该指针指向的位置进行修改，但是不能对实际的指针进行修改
    
    - 预处理指令
    
        预处理器在编译程序编译代码之前对其进行处理。所有的预处理执行都必须以 `#` 开始
    
        ```cpp
        #define 宏名 宏定义字符串
        #define 宏名(参数1,参数2,...,参数n)宏定义字符串
    
        #if 常量表达式1	//或 #ifdef 标识符，#ifndef 标识符
            程序段1
        #elif 常量表达式2
            程序段2
            ...
        #else
            程序段n
        #endif
        ```
    
        `#include "filename"`：一般预处理器将在当前源程序所在的目录中寻找该文件。如果在当前目录中没有找到该文件，那么编译器将在标准目录中寻找该文件
    
        `#include<filename>`：仅在标准目录中寻找这些文件
    
        `#line`、`#error`、`#progma`，用于构造 C 程序
    
    - 字符串：
    
        `strcat(s,t)`：把字符串 t 拼接到 s 的末尾（覆盖 s 原有的 \0，并在拼接后新增 '\0'）
    
        `strcmp(s,t)`：比较。相等返回 0，大于返回正数，小于返回负数
    
        `strcpy(s,t)`：s = t
    
        `strchr(s,c)`：在字符串 s 中找字符 c 首次出现的地址
    
        `strstr(s,t)`：在字符串 s 中找字符串 t 首次出现的地址
        
        `char *p="hello";strcpy(p,"world");` 会 RE，因为 "hello" 是字符串常量，p 指向的是只读内存。同理 `char *a="hello"; a[0]='H';` 会 RE，因为 "hello" 存在于静态存储区中，是只读的，不能进行修改
        
        strcpy/strcat 的 s 必须是可写的 char*（不能是字符串常量），strcpy/strcat 的 t、strcmp/strchr/strstr 的s/t 只需要可读的 const char*（字符数组 / 字符串常量均可）
    
    - 动态内存分配函数
    
        `void *colloc(unsigned int n,unsigned int size)`：分配 n 个连续存储单元，每个但愿包含 size 个字节
    
        `void *alloc(unsigned int size)`：分配 size 个字节的存储单元块
    
        `void free(void *p)`：释放 p 所指内存单元块。p 必须严格是动态内存分配函数（malloc/calloc/realloc）返回的原始首地址，不能是该地址偏移后的指针
    
        `void *realloc(void *p,unsigned int size)`：将 p 所指的已分配存储单元块的大小改为 size
    
    - typedef
    
        已知一个函数指针类型，它所指的函数返回值类型为空类型，接收两个参数：一个是字符指针类型，一个是整型。用 typedef 将该函数指针类型命名为 FunType：`typedef void (*FunType)(char *, int);`
    
        假设已有结构类型定义：`struct point { int a, int b };` 请用 `typedef` 把具有 5 个上述结构类型元素的数组类型重新命名为 RECT：`typedef struct point RECT[5];`
    
        用 typedef 写出类型 POINT 的定义，使得 POINT 表示指向由 10 个字符指针构成的数组的指针类型：`typedef char* (*POINT)[10];`
    
        typedef 与 define 区别：比如 `typedef int* IntPtr;`（记得不要漏掉 `;`）和 `#define IntPtr int*`，定义 `IntPtr a,b;`，前者相当于 `int *a,*b`（a 和 b 都是 int*），后者相当于 `int* a,b;`（b 是 int）
    
    - argc：参数个数（含程序名）；argv：字符串数组，argv[0] 为程序名，argv[1] 为第一个参数
    - `int k=11;printf("%d,%o,%x",k,k,k);` 输出 `11,13,b` 而非 `11,013,0xb` （不输出前导符）
    
    - 一个函数的定义不可以完整地包含另一个函数的定义
    
    - 文件
    
        ```cpp
        fgetc(fp);
        fputc(ch,fp);
        fgets(s,n,fp);
        fputs(s,fp);
        FILE *fp=fopen(fname,mode);
        fclose(fp);	//成功返回 0
        feof(fp);
        fread(a,sizeof(T),n,fp);
        fwrite(a,sizeof(T),n,fp);
        rewind(fp);
        fseek(fp,n,posi);	//成功返回 0
        ftell(fp);
        remove(fname);	//成功返回 0
        rename(oldfname,newfname);	//成功返回 0
        ```
        
        使用 `FILE *fopen(char *文件名, char *模式)` 打开文件，返回对应的文件指针。如果返回值为 NULL 说明文件打开失败。
    
    	使用 `int fclose(FILE *文件指针)` 关闭文件，如果返回值非 0 说明文件关闭失败。
    	
    	使用 `char fgetc(FILE* file)` 读取单个字符。
    	
    	使用 `void fputc(char c, FILE* file)` 写入单个字符。
    	
    	使用 `char *fgets(char *s, int n, FILE* file)` 读取字符串：连续读取至多 n-1 个字符并将其保存到 s 中。如果遇到换行符（会保留换行符）或 EOF（不保留）则截止，并自动往末尾添加 '\0'。执行成功时返回读取到的字符串，否则返回 NULL。
    	
    	使用 `char *fputs(char *s, FILE *file)` 写入字符串
    	
    	还可以使用 `fscanf` 与 `fprintf`，第一个参数是文件指针，后面参数和 scanf 与 printf 的使用方法相同。
    	
    	使用 `fread(void* 数据块(首)地址, size_t 单个数据块字节数, size_t 要读入的数据块个数, FILE* 文件指针)` 来从以二进制模式打开的文件中读取数据。
    
    	使用 `fwrite(void* 数据块(首)地址, size_t 单个数据块字节数, size_t 要读入的数据块个数, FILE* 文件指针)` 来往以二进制模式打开的文件中写入数据。
    
    	使用 `int feof(FILE* 文件指针)` 判断文件尾是否已经被尝试读取。（如 fgetc 已经返回 EOF 而不是将要返回 EOF）
    	
    	使用 `rewind(FILE* 文件指针)` 使得文件读写指针恢复到打开文件时所指向的位置（字节数）。
    	
    	使用 `fseek(FILE* 文件指针, size_t 偏移量, int 起始位置)` 来移动读写指针，其中起始位置可选值为 0（SEEK_SET）、1（SEEK_CUR）、2（SEEK_END） 分别对应文件头、当前位置、文件尾。
    	
    	使用 `ftell(FILE* 文件指针)` 获取文件指针的位置（字节数），即相对于文件开头的偏移量。

	- printf() 中参数传递从右往左

??? warning "注意"

    `#if`，`#ifdef` 的区别
    
    不能解引用 NULL
    
    sizeof 运算符计算数据类型 / 变量 / 数组占用的字节数
    
    sizeof 包含字符串末尾的 '\0'，strlen 不包含 '\0'。注意看清楚 sizeof(s) 的 s 是字符串还是字符数组。注意 sizeof(数组名) 算的不是数组大小，是 数组大小 × 类型的字节数。注意 `\012` 不是 `\0` 再 `12`。
    
    浮点转整型：强制转换 (int) 遵循向零截断，仅丢弃小数部分，不四舍五入
    
    逻辑与 &&：左侧为假（0）时，右侧表达式短路不执行；
    
    数组名 a：常量指针，地址不可修改
    
    指针 ± 整数：地址偏移量 = 整数 × 指向类型的字节数。但是 指针 - 指针 算的不是地址相减，而是 q-p=((int)q-(int)p)/sizeof(*p)。除非 (char*)q-(char*p)，单位就是一个字节；或者 (int)q-(int)p
    
    scanf 按格式符逐个匹配，遇到不匹配字符停止当前变量读取
    
    C 语言中 switch 语句的 case 后常量表达式不支持浮点型（如 float、double），仅允许整型（如 int、long）、字符型（本质是 ASCII 码对应的整型）、枚举型
    
    如果所有 case 都不满足，执行 default，加入 default 后面没写 break，还会执行 default 下面的语句直到遇到 break 为止
    
    多维数组记得看清楚每维大小，不要只看初始化列表搞错了

## 刷历年卷

??? info "2015-2016"

	把数组 int a[10][20] 传入函数 aver 求平均值，不正确的代码段是
	
	A.
	
	```cpp
	int a[10][20] = {1,2,3,4,5};
	aver(a, 200); 
	float aver(int *a, int size) { /*…*/ }
	```
	
	C.
	
	```cpp
	int a[10][20] = {1,2,3,4,5};
	aver(*a, 200); 
	float aver(int *a, int size) { /*…*/ }
	```
	
	??? note "解答"
		答案：A
		
		A. `a` 作为数组名传参时会 “退化” 为数组指针，类型为 `int (*)[20]`，与形参 `int *a` 类型不匹配，会 CE
		
		C. `a` 等价于指向 `a[0]` 的数组指针，所以 `*a` 等价于 `a[0]`，等价于 `&a[0][0]`，类型为 `int*`，与形参 `int *a` 类型匹配

??? info "2014-2015"
	对于变量定义 `int x, a[8], *p=&a[0];`，表达式______是不正确的

	A．x = a[7]	  B．x = *(p+3)	    C．x = *p++	      D. x = *a++
	
	??? note "解答"
		答案：D
		
		a：是数组名，本质是一个常量指针（指向数组首元素 a[0] 的地址），常量指针的地址值不能被修改（即不能做自增 / 自减操作）；
		
		p：是指针变量（指向 a[0]），变量可以被修改（支持 p++、p-- 等操作）；
	
	设有 `double a[4]={10, 20, 30, 40}, *p=&a[3]; p=p-2;` 且假定 &a[0] 为 0xFFD8，则 `printf("%x", p);` 将输出
	
	A．FFD9	B．FFE0	C．FFEE	D．FFF0
		
	??? note "解答"
		答案：B
		
		指针加减整数时，偏移量是「整数 × 指向类型的字节数」，而非单纯的字节数
		
		a[1] 的地址是 0xFFD8 + 8 = 0xFFE0


	设 `int i=0, j=9; char s[ ] = "happy new year!", *sp=s,*sq=s+9;` 执行下列哪一条语句所得到的结果和其他三项不同
	
	A．`while ( i <= j ) s[i++]=s[j--];`	B．`for ( ; i<=j; ++i, --j ) s[i]=s[j];`
	C．`for ( ; sp++ <= sq--; ) *sp = *sq;`	D．`do { *sp=*sq; } while( sp++ < sq-- );`
	
	??? note "解答"
		答案：C
		
		C. for 循环条件是 `sp++ <= sq--`，导致第一次赋值时 sp 已指向 s[1]，漏掉了 s[0] 的赋值，多覆盖了 s[5]
	
	以下程序段的输出是
	
	```c
	int i;  char s[80]={"apple\0grape\0pear\0coco\0"};
	for(i=0; i<2; i++) s[strlen(s)] = '\n';
	printf("%d#%d\n",strlen(s),sizeof(s) );
	```
	
	??? note "解答"
		答案：`16#80`
		
		strlen：计算字符串长度，从起始位置到第一个'\0'为止，不包含'\0'
		
		sizeof：计算数组 / 变量的内存字节数，对数组 s[80] 来说，结果固定为 80（和内容无关）
	
	假设一个指针变量 8 个字节，则以下程序的运行结果是
	
	```c
	int f(long a[])                      
	{   
	    return (int)sizeof(a);
	}
	void main()
	{   
	    long a[][3] = {1,2,3,4},*p;
	    printf("%d#%d\n",sizeof(a),f(a[0]));
	}
	```
	
	??? note "解答"
		答案：`24#8`
		
		a 是二维数组名，计算整个数组的字节数：总元素数 = 行数 × 列数 = 2 × 3 = 6 个，每个 long 占 4 字节，总字节数 = 6 × 4 = 24


??? info "2013-2014"
	在 C 语言中，下列表达式的值最大的是
	A．`sizeof('a')`	B．`sizeof(97)`	C．`sizeof("aaaa")`	D．`sizeof(97.0)`
		
	??? note "解答"
		答案：D
		
		A. 'a' 是字符常量，在 C 语言中，字符常量的本质是 int 类型。4 字节
		
		B. 97 是整数常量，默认类型是 int。4 字节
		
		C. "aaaa" 是字符串常量，C 语言中字符串以 '\0'（空字符）结尾。"aaaa" 包含 4 个 'a' + 1 个 '\0'，共 5 个字符，每个字符是 char 类型（1 字节）。5 字节
		
		D. 97.0 是浮点常量，默认类型是 double（双精度浮点型）。8 字节
	
	已知 `unsigned short  m=65539;` 则执行语句 `printf("%d", m);` 后的输出结果是
	
	??? note "解答"
		答案：3
		
		无符号整数溢出，对 $2^{16}=65536$ 取模
	
	假设 a 是一个 float 变量，语句：`printf(____________)` 可将 a 按照保留两位小数的百分率形式输出，例如 a=0.32049 就应输出 32.05%（注意需有百分号）
	
	??? note "解答"
		`"%.2f%%", a*100` 或 `"%.2f%c", a*100,'%'`
	
	对于以下代码段，若输入 `12e-0x34.56`，则输出结果是
	
	```c
	float f; char c; int d;
	scanf("%f%c%d", &f, &c, &d);
	printf("%.2f%c%d", f, c, d);
	```
	
	??? note "解答"
		答案：`12.00x34`
		
		scanf 按格式符逐个匹配输入内容，遇到无法匹配当前格式符的字符时，会停止对当前变量的读取，并将该字符留给下一个格式符匹配；若某个格式符完全无法匹配，则对应变量赋值失败（值未定义）
		
		f：`12e-0`
		
		c：`'x'`
		
		d：`34`
	
	下列程序段的输出结果是
	
	```c
	char s[]="xyz", *ps=s;
	while (*ps++);   ps--;
	for(ps--; ps-s>=0; ps--) printf("%s#",ps);  
	```
	
	??? note "解答"
		答案：`z#yz#xyz#`
		
		`printf("%s", ps)`：从 ps 指向的地址开始输出字符，直到遇到 '\0' 为止。

??? info "2011-2012"
	表达式 `-10>>2+3` 的值为______（假设是算术移位）
	
	??? note "解答"
		答案：-1
		
		有符号整数以补码形式存储和运算
		
		-10 的 8 位补码是 1111 0110，右移 5 位得到 1111 1111（补 5 个 1），对应进制 -1


​	